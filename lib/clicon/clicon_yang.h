/*
 *  CVS Version: $Id: clicon_spec.h,v 1.15 2013/09/20 11:45:08 olof Exp $
 *
  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren
  Olof Hagsand
 *
  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 */

#ifndef _CLICON_YANG_H_
#define _CLICON_YANG_H_

/*
 * Types
 */
/*! yang statement */
struct yang_stmt{
    int                ys_len;
    struct yang_stmt **ys_stmt;
    struct yang_node  *ys_parent;    /* backpointer to parent: yang-stmt or yang-spec */
    int                ys_keyword;   /* See clicon_yang_parse_tab.h */
    char              *ys_argument;  /* String / argument depending on keyword */   
    char              *ys_dbkey;     /* dbspec key corresponding to this yang node */
    cg_var            *ys_cv;        /* cligen variable corresponding to this (if leaf) node */
    int                ys_mandatory; /* mandatory false|true */
    int64_t            ys_range_min; /* for range and length stmts */
    int64_t            ys_range_max; /* for range and length stmts */
};
typedef struct yang_stmt yang_stmt;

#define YANG_SPEC -99 /* other keywords generated by yacc starts at 258 */
/*! top-level yang parse-tree */
struct yang_spec{
    int                yp_len;
    struct yang_stmt **yp_stmt;
    struct yang_node  *yp_parent; /* backpointer to parent: always NULL. See yang_stmt */
    int                yp_keyword; /* SHOULD BE YANG_SPEC */
};
typedef struct yang_spec yang_spec;

/*! super-class of yang_stmt and yang_spec: it must start exactly as those two classes */
struct yang_node{
    int                yn_len;
    struct yang_stmt **yn_stmt;
    struct yang_node  *yn_parent; /* backpointer to parent: yang-stmt or yang-spec */
    int                yn_keyword; 
};
typedef struct yang_node yang_node;

typedef int (yang_applyfn_t)(yang_stmt *ys, void *arg);

/*
 * Prototypes
 */
yang_spec *yspec_new(void);
yang_stmt *ys_new(int keyw);
int        ys_free(yang_stmt *ys);
int        yspec_free(yang_spec *yspec);
int        yn_insert(yang_node *yn_parent, yang_stmt *ys_child);

yang_stmt *yn_each(yang_node *yn, yang_stmt *ys);
char      *yang_key2str(int keyword);
yang_stmt *yang_find(yang_node *yn, int keyword, char *argument);
yang_stmt *yang_find_specnode(yang_node *yn, char *argument);

int        yang_print(FILE *f, yang_node *yn, int marginal);
int        yang_parse(clicon_handle h, const char *filename, yang_spec *ysp);
int        yang2cv_type(char *ytype, enum cv_type *cv_type);
char      *cv2yang_type(enum cv_type cv_type);
char      *yang_dbkey_get(yang_stmt *ys);
int        yang_dbkey_set(yang_stmt *ys, char *val);
int        yang_apply(yang_node *yn, yang_applyfn_t fn, void *arg);
yang_stmt *dbkey2yang(yang_node *yn, char *dbkey);
yang_stmt *yang_xpath(yang_node *yn, char *xpath);
cg_var    *ys_parse(yang_stmt *ys, enum cv_type cvtype);
int        ys_parse_sub(yang_stmt *ys);
int        ys_cv_validate(cg_var *cv, yang_stmt *ys, char **reason);

#endif  /* _CLICON_YANG_H_ */
