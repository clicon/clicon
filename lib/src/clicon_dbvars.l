/*
 *
  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 *
 * Lvalues
 */

%{
#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include "clicon_log.h"
#include "clicon_err.h"
#include "clicon_queue.h"
#include "clicon_hash.h"
#include "clicon_handle.h"
#include "clicon_dbspec_key.h"
#include "clicon_lvalue.h"
#include "clicon_dbvars.tab.h"
#include "clicon_dbvars.h"

/* Dont use input function (use user-buffer) */
#define YY_NO_INPUT

/* Redefine main lex function so that you can send arguments to it */
#define YY_DECL int clicon_dbvarslex(void *_ya)

#define _YA ((clicon_dbvarsparse_t *)_ya)

#undef clicon_dbvarswrap
int 
clicon_dbvarswrap(void)
{
  return 1;
}

void clicon_dbvarserror(void *_ya, char *str)
{
    fprintf(stderr,"error: %s at or before '%s'\n",str, clicon_dbvarstext);
}


#if 0
#define CDM_DEBUG(s)  if (debug) fputs((s),stderr);
#else
#define CDM_DEBUG(s)
#endif

%}

%%

[ \t\n\0]+		{ CDM_DEBUG("WHITE "); return WHITE; }
\$			{ CDM_DEBUG("$ "); return *yytext; }
\=			{ CDM_DEBUG("= "); return *yytext; }
\(			{ CDM_DEBUG("( "); return *yytext; }
\)			{ CDM_DEBUG(") "); return *yytext; }
\"([^\\\"]|\\.)*\"	{ 
			clicon_dbvarslval.string=strdup(yytext+1);
			clicon_dbvarslval.string[strlen(clicon_dbvarslval.string)-1] = '\0';
			CDM_DEBUG("STRING ");
			return STRING;
			}
[^\$=\"\(\) \t\n\0]+  {
			clicon_dbvarslval.string=strdup(yytext);
			CDM_DEBUG("NAME ");
			return NAME; }
.			return -1;

%%


/*
 * clicon_dbvars_parse
 * Parse a db modification format and return a struct containing the key and
 * a variable list. The key is untouched and any formatting need to be done
 * separately.
 * Format is "<key> <var> <var> ..." where <var> can be one of the following:
 * $var                   - Assign next value from the given cligen var-list
 * $var=$N                - Where 'N' is a number. Assign N:th value from cligen var-list
 * $var=$varname          - Assign the variable named 'varname' from cligen var-list
 * $var=(type)<val>	  - Where type can be one of the below types.
 *                            string|int|ipv4addr|ipv4prefix|ipv6addr|ipv6prefix|url
 * $var=[<plugin>::]<func>() - Assign value returned by specified callback.
 */ 
clicon_dbvars_t *
clicon_dbvars_parse_fmt(cvec *vars,
		       const char *fmt,
		       clicon_dbvalcb_t *cb,
		       void *cb_arg)	/* user arg passed back to callback */

{
    size_t len;
    clicon_dbvarsparse_t dvp;
    char *s, *s0 = NULL;
    YY_BUFFER_STATE state;
    clicon_dbvars_t *ret = NULL;

    memset(&dvp, 0, sizeof(dvp));
    dvp.dvp_valcb = cb;
    dvp.dvp_varidx = 1;	/* Start from vr_vec[1] */
    dvp.dvp_vars = vars;
    dvp.dvp_arg = cb_arg;
    if ((dvp.dvp_ret = malloc(sizeof(clicon_dbvars_t))) == NULL) {
	clicon_err(OE_UNIX, errno, "malloc");
	goto done;
    }
    memset(dvp.dvp_ret, 0, sizeof(*dvp.dvp_ret));
    dvp.dvp_ret->dbv_key = NULL;
    if ((dvp.dvp_ret->dbv_vec = cvec_new(0)) == NULL) {
	clicon_err(OE_UNIX, errno, "malloc");
	return NULL;
    }
    /* Skip leading whitespace in fmt*/
    while(isspace(*fmt)) fmt++; 

    if ((s0 = malloc(strlen(fmt)+3)) == NULL) {
        clicon_err(OE_UNIX, errno, "malloc");
        goto done;
    }
    memset(s0,'\0',strlen(fmt)+3);
    strcpy(s0, fmt);
    s0[strlen(s0)] = '\n'; 

    /* Store key */
    len = strcspn(s0, " \t\n\0");
    if ((dvp.dvp_ret->dbv_key = malloc(len+1)) == NULL) {
	clicon_err(OE_UNIX, errno, "malloc");
	return NULL;
    }
    snprintf(dvp.dvp_ret->dbv_key, len+1, "%s", s0);
    dvp.dvp_ret->dbv_key[len] = '\0';

    /* Skip key and following whitespace */
    s = s0 + len;
    while (isspace(*s)) s++;

    state = yy_scan_buffer(s, strlen(s)+2);
    if (clicon_dbvarsparse((void *)&dvp) == 0)
	ret = dvp.dvp_ret;
#if 1 /* XXX: just to use unput to avoid warning  */
  if (0)
    yyunput(0, ""); 
#endif
    yy_delete_buffer( state );
#if defined(YY_FLEX_SUBMINOR_VERSION) && YY_FLEX_SUBMINOR_VERSION >= 9
    clicon_dbvarslex_destroy();
#else
    yy_init = 1;      /* This does not quite free all buffers */
#endif
    
done:
    if (s0)
        free(s0);
    if (ret == NULL && dvp.dvp_ret)
	clicon_dbvars_free(dvp.dvp_ret);
    
    return ret;
}
