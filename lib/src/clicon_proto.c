/*
 *  CVS Version: $Id: clicon_proto.c,v 1.14 2013/08/15 11:30:23 olof Exp $
 *
  Copyright (C) 2009-2013 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 *
 * Protocol to communicate with OSR config daemon
 */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
#include <assert.h>
#include <syslog.h>
#include <signal.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <netinet/in.h>
#include <sys/un.h>
#include <arpa/inet.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include "clicon_err.h"
#include "clicon_log.h"
#include "clicon_queue.h"
#include "clicon_chunk.h"
#include "clicon_sig.h"
#include "clicon_proto.h"
#include "clicon_proto_encode.h"

static int _atomicio_sig = 0;

/*
 * clicon_connect_unix
 * open local connection using unix domain sockets
 */
int
clicon_connect_unix(char *sockpath)
{
    struct sockaddr_un addr;
    int retval = -1;
    int s;

    if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
	clicon_err(OE_CFG, errno, "socket");
	return -1;
    }
    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, sockpath, sizeof(addr.sun_path)-1);

    clicon_log(LOG_DEBUG, "%s: connecting to %s", __FUNCTION__, addr.sun_path);
    if (connect(s, (struct sockaddr *)&addr, SUN_LEN(&addr)) < 0){
	if (errno == EACCES)
	    clicon_err(OE_CFG, errno, "connecting unix socket: %s.\n"
		       "Client should be member of group $CLICON_SOCK_GROUP: ", 
		       sockpath);
	else
	    clicon_err(OE_CFG, errno, "connecting unix socket: %s", sockpath);
	close(s);
	goto done;
    }
    retval = s;
  done:
    return retval;
}



static void
atomicio_sig_handler(int arg)
{
    _atomicio_sig++;
}


/*
 * atomicio
 * ensure all of data on socket comes through. fn is either read or write
 */
static ssize_t
atomicio(ssize_t (*fn) (int, void *, size_t), int fd, void *_s, size_t n)
{
    char *s = _s;
    ssize_t res, pos = 0;

    while (n > pos) {
	_atomicio_sig = 0;
	res = (fn)(fd, s + pos, n - pos);
	switch (res) {
	case -1:
	    if (errno == EINTR){
		if (!_atomicio_sig)
		    continue;
	    }
	    else
		if (errno == EAGAIN)
		    continue;
	case 0: /* fall thru */
	    return (res);
	default:
	    pos += res;
	}
    }
    return (pos);
}

static int
msg_dump(struct clicon_msg *msg)
{
    int i;
    char buf[9*8];
    char buf2[9*8];
    
    memset(buf2, 0, sizeof(buf2));
    snprintf(buf2, sizeof(buf2), "%s:", __FUNCTION__);
    for (i=0; i<msg->op_len; i++){
	snprintf(buf, sizeof(buf), "%s%02x", buf2, ((char*)msg)[i]&0xff);
	if ((i+1)%32==0){
	    clicon_log(LOG_DEBUG, buf);
	    snprintf(buf, sizeof(buf), "%s:", __FUNCTION__);
	}
	else
	    if ((i+1)%4==0)
		snprintf(buf, sizeof(buf), "%s ", buf2);
	strncpy(buf2, buf, sizeof(buf2));
    }
    if (i%32)
	clicon_log(LOG_DEBUG, buf);
    return 0;
}

int
clicon_msg_send(int s, struct clicon_msg *msg)
{ 
    int retval = -1;

    clicon_log(LOG_DEBUG, "%s: send msg seq=%d len=%d", 
	    __FUNCTION__, msg->op_type, msg->op_len);
    if (debug > 1)
	msg_dump(msg);
    if (atomicio((ssize_t (*)(int, void *, size_t))write, 
		 s, msg, msg->op_len) < 0){
	clicon_err(OE_CFG, errno, "%s", __FUNCTION__);
	goto done;
    }
    retval = 0;
  done:
    return retval;
}


/*
 * clicon_msg_rcv
 * XXX: timeout? and signals?
 * There is rudimentary code for turning on signals and handling them 
 * so that they can be interrupted by ^C. But the problem is that this
 * is a library routine and such things should be set up in the cli 
 * application for example: a daemon calling this function will want another 
 * behaviour.
 * Now, ^C will interrupt the whole process, and this may not be what you want.
 */
int
clicon_msg_rcv(int s,
	      struct clicon_msg **msg,
	      int *eof,
	      const char *label)
{ 
    int retval = -1;
    struct clicon_msg hdr;
    int len, len2;
    sigfn_t   oldhandler;

    *eof = 0;
    if (0)
	set_signal(SIGINT, atomicio_sig_handler, &oldhandler);

    if ((len = atomicio(read, s, &hdr, sizeof(hdr))) < 0){ 
	clicon_err(OE_CFG, errno, "%s", __FUNCTION__);
	goto done;
    }
    if (len == 0){
	retval = 0;
	*eof = 1;
	goto done;
    }
    if (len != sizeof(hdr)){
	clicon_err(OE_CFG, errno, "%s: header too short (%d)", __FUNCTION__, len);
	goto done;
    }
    clicon_log(LOG_DEBUG, "%s: rcv msg seq=%d, len=%d",  
	    __FUNCTION__, hdr.op_type, hdr.op_len);
    if ((*msg = (struct clicon_msg *)chunk(hdr.op_len, label)) == NULL){
	clicon_err(OE_CFG, errno, "%s: chunk", __FUNCTION__);
	goto done;
    }
    memcpy(*msg, &hdr, len);
    if ((len2 = read(s, (*msg)->op_body, hdr.op_len - sizeof(hdr))) < 0){
	clicon_err(OE_CFG, errno, "%s: read", __FUNCTION__);
	goto done;
    }
    if (len2!= hdr.op_len - sizeof(hdr)){
	clicon_err(OE_CFG, errno, "%s: body too short", __FUNCTION__);
	goto done;
    }
    if (debug > 1)
	msg_dump(*msg);
    retval = 0;
  done:
    if (0)
	set_signal(SIGINT, oldhandler, NULL);
    return retval;
}


/*
 * clicon_rpc_connect
 * Connect to server, send an clicon_msg message and wait for result.
 * Compared to clicon_rpc, this is a one-shot rpc: open, send, get reply and close.
 */
int
clicon_rpc_connect(struct clicon_msg *msg, char *sockpath,
		   char **data, uint16_t *datalen,
		   const char *label)
{
    int retval = -1;
    int s = -1;
    struct stat sb;

    /* special error handling to get understandable messages (otherwise ENOENT) */
    if (stat(sockpath, &sb) < 0){
	clicon_err(OE_PROTO, errno, "%s: config daemon not running?", sockpath);
	goto done;
    }
    if (!S_ISSOCK(sb.st_mode)){
	clicon_err(OE_PROTO, EIO, "%s: Not unix socket", sockpath);
	goto done;
    }
    if ((s = clicon_connect_unix(sockpath)) < 0)
	goto done;
    if (clicon_rpc(s, msg, data, datalen, label) < 0)
	goto done;
    retval = 0;
  done:
    if (s >= 0)
	close(s);
    return retval;
}

/*
 * clicon_rpc
 * Send an clicon_msg message and wait for result.
 * TBD: timeout, interrupt?
 * retval may be -1 and
 * errno set to ENOTCONN which means that socket is now closed probably
 * due to remote peer disconnecting. The caller may have to do something,...
 */
int
clicon_rpc(int s, struct clicon_msg *msg, 
	   char **data, uint16_t *datalen,
	   const char *label)
{
    int retval = -1;
    struct clicon_msg *reply;
    int eof;
    uint32_t err, suberr;
    char *reason;

    if (clicon_msg_send(s, msg) < 0)
	goto done;
    if (clicon_msg_rcv(s, &reply, &eof, label) < 0)
	goto done;
    if (eof){
	clicon_err(OE_PROTO, ESHUTDOWN, "%s: Socket unexpected close", __FUNCTION__);
	close(s);
	errno = ESHUTDOWN;
	goto done;
    }
    switch (reply->op_type){
    case CLICON_MSG_OK:
        if (data != NULL) {
	    *data = reply->op_body;
	    *datalen = reply->op_len - sizeof(*reply);
	}
	break;
    case CLICON_MSG_ERR:
	if (clicon_msg_err_decode(reply, &err, &suberr, &reason, label) < 0) 
	    goto done;
	clicon_err(err, suberr, "%s", reason);
	goto done;
	break;
    default:
	clicon_err(OE_PROTO, 0, "%s: unexpected reply: %d", 
		__FUNCTION__, reply->op_type);
	goto done;
	break;
    }
    retval = 0;
  done:
    return retval;
}

int 
send_msg_reply(int s, uint16_t type, char *data, uint16_t datalen)
{
    struct clicon_msg *reply;
    int retval = -1;
    int len;

    len = sizeof(*reply) + datalen;
    if ((reply = (struct clicon_msg *)chunk(len, __FUNCTION__)) == NULL)
	goto done;
    memset(reply, 0, len);
    reply->op_type = type;
    reply->op_len = len;
    if (datalen > 0)
      memcpy(reply->op_body, data, datalen);

    if (clicon_msg_send(s, reply) < 0)
	goto done;
    retval = 0;
  done:
    unchunk_group(__FUNCTION__);
    return retval;
}

int
send_msg_ok(int s)
{
    return send_msg_reply(s, CLICON_MSG_OK, NULL, 0);
}

int
send_msg_notify(int s, char *event)
{
    int retval = -1;
    struct clicon_msg *msg;

    if ((msg=clicon_msg_notify_encode(event, __FUNCTION__)) == NULL)
	goto done;
    if (clicon_msg_send(s, msg) < 0)
	goto done;

    retval = 0;
  done:
    unchunk_group(__FUNCTION__);
    return retval;
}

int
send_msg_err(int s, int err, int suberr, char *format, ...)
{
    va_list args;
    char *reason;
    int len;
    int retval = -1;
    struct clicon_msg *msg;

    va_start(args, format);
    len = vsnprintf(NULL, 0, format, args) + 1;
    va_end(args);
    if ((reason = (char *)chunk(len, __FUNCTION__)) == NULL)
	return -1;
    memset(reason, 0, len);
    va_start(args, format);
    vsnprintf(reason, len, format, args);
    va_end(args);
    if ((msg=clicon_msg_err_encode(clicon_errno, clicon_suberrno, 
				   reason, __FUNCTION__)) == NULL)
	goto done;
    if (clicon_msg_send(s, msg) < 0)
	goto done;

    retval = 0;
  done:
    unchunk_group(__FUNCTION__);
    return retval;
}
