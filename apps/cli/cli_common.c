/*
 *  CVS Version: $Id: cli_common.c,v 1.154 2013/09/20 11:47:01 olof Exp $
 *
  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 * 
 */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <errno.h>
#include <stdarg.h>
#include <time.h>
#include <ctype.h>

#include <unistd.h>
#ifdef HAVE_CRYPT_H
#include <crypt.h>
#endif 
#include <dirent.h>
#include <syslog.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/wait.h>
#include <sys/param.h>
#include <sys/mount.h>
#include <pwd.h>
#include <assert.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clicon/clicon.h>

#include "clicon_cli_api.h"

#include "cli_common.h"


/*
 * init_candidate_db
 * There are several variants in Junos. We have implemented these:
 * private - every user has an own candidate db (last one commit wins)
 * shared - all users share a common candidate db
 * current - use current as candidate
 * exclusive - only one user can have a candidate (not implemented)
 */
int 
init_candidate_db(clicon_handle h, enum candidate_db_type type)
{
    int retval = -1;
    struct stat  sb;
    char *running_db = clicon_running_db(h);
    char *candidate_db = clicon_candidate_db(h);
    char *s;

    cli_set_candidate_type(h, type);
    switch(type){
    case CANDIDATE_DB_NONE:
	break;
    case CANDIDATE_DB_PRIVATE:
	if (lstat(candidate_db, &sb) < 0){
	    if (file_cp(running_db, candidate_db) < 0){
		clicon_err(OE_UNIX, errno, "Error when copying %s to %s: %s\n", 
			running_db, candidate_db,
			strerror(errno));
		unlink(candidate_db);
		goto err;
	    }
	}
	break;
    case CANDIDATE_DB_SHARED:
	if (lstat(candidate_db, &sb) < 0){
	    s = clicon_sock(h);
	    cli_proto_copy(s, running_db, candidate_db);
	}
	break;
    case CANDIDATE_DB_CURRENT:
	clicon_option_str_set(h, "CLICON_CANDIDATE_DB",  running_db);
	break;
    }
    retval = 0;
  err:
    return retval;
}

/*
 * exit_candidate_db
 * private canddidates should be removed
 */
int 
exit_candidate_db(clicon_handle h)
{
//    struct stat  sb;

    switch(cli_candidate_type(h)){
    case CANDIDATE_DB_PRIVATE:
#if 0 /* XXX: maybe we should remove it, but I want several cli:s to edit it */
	if (lstat(clicon_candidate_db(h), &sb) == 0)
	    unlink(clicon_candidate_db(h));
#endif
	break;
    default:
	break;
    }
    return 0;
}

/* 
 * CLI output callback. 
 * 'str' is already pre-formatted. Make sure we make "%%" out of all "%" 
 * before sending to cligen_output()
 */
void
cli_output_cb (char *str)
{
  int idx;
  int npcnt;
  char *new;
  char *newp;

  /* Count number of '%' to know how large the new string need to be */
  for (npcnt = idx = 0; str[idx]; idx++)
    if (str[idx] == '%')
      npcnt++;

  /* Allocate new string */
  new = malloc (strlen (str) + npcnt + 1);
  if (!new)
    new = str;

  /* Copy string to new string, doubling all '%' */
  newp = new;
  for (idx = 0; str[idx]; idx++) {
    if (str[idx] == '%')
      *newp++ = '%';
    *newp++ = str[idx];
  }
  *newp++ = '\0';

  cligen_output (stdout, new);
  fflush (stdout);

  free (new);
}

/* 
 * CLI output format callback. 
 * Format a string and send print to user.
 */
void 
cli_fmt_output_cb(char *fmt, ...)
{
  char *str;
  va_list ap;
  int len;

  va_start(ap, fmt);
  len = vsnprintf(NULL, 0, fmt, ap);
  va_end(ap);
  if (len <= 0 || (str = (char *)chunk(len+1, __FUNCTION__)) == NULL) {
    fprintf(stderr, "Error: Failed to allocate memory\n");
    return;
  }
  va_start(ap, fmt);
  vsnprintf(str, len+1, fmt, ap);
  str[len] = '\0';
  va_end(ap);

  cli_output_cb(str);
  unchunk_group(__FUNCTION__);
}

/*
 * Run external process command.
 */
int 
cli_run(clicon_handle h, cvec *vr, cg_var *arg)
{
  int ret;
  char *cmd;

  cmd = cgv_fmt_string (vr, cv_string_get(arg));
  if (cmd == NULL)
    return 0;

  ret = clicon_proc_run(cmd, cli_output_cb, 1);
  free (cmd);

  return ret;
}




/*
 * Set multiple db values.
 * arg is a vector of args delimited by ';'
 */
int 
cli_mset(clicon_handle h, cvec *vars, cg_var *argv)
{
    char **vec = NULL;
    int i, nvec;
    int retval = -1;
    cg_var *cv;

    if ((vec = clicon_strsplit(cv_string_get(argv), ";", &nvec, __FUNCTION__)) == NULL){
	goto catch;
    }
    for (i=0; i<nvec; i++){
	if ((cv = cv_new(CGV_STRING)) == NULL){
	    cligen_output(stderr, "Allocating cligen object: %s\n", strerror(errno)); 
	    goto catch;
	}
	if (cv_parse(vec[i], cv) < 0) { 
	    cligen_output(stderr, "Failed to parse string to cgv\n");
	    goto catch;
	}
	if (cli_set(h, vars, cv) < 0) {
	    cv_free(cv);
	    goto catch;
	}
	cv_free(cv);
    }
    retval = 0;
 catch:
  unchunk_group(__FUNCTION__) ;
  return retval;
}


/*
 * Merge multiple db values.
 * arg is a vector of args delimited by ';'
 */
int 
cli_mmerge(clicon_handle h, cvec *vars, cg_var *arg)
{
    char **vec = NULL;
    int i, nvec;
    int retval = -1;
    cg_var *cv = NULL; 

    if ((vec = clicon_strsplit(cv_string_get(arg), ";", &nvec, __FUNCTION__)) == NULL){
	goto catch;
    }
    for (i=0; i<nvec; i++){
	if ((cv = cv_new(CGV_STRING)) == NULL){
	    cligen_output(stderr, "Allocating cligen object: %s\n", strerror(errno)); 
	    goto catch;
	}
	if (cv_parse(vec[i], cv) < 0) { /* NULL */
	    cligen_output(stderr, "Failed to parse string to cgv\n");
	    goto catch;
	} 
	if (cli_merge(h, vars, cv) < 0) {
	    goto catch;
	}
	cv_free(cv);
    }
    retval = 0;
 catch:
    if (cv)
	cv_free(cv);
  unchunk_group(__FUNCTION__) ;
  return retval;
}


#if FIXME
/* XXX
   Only called from osr junos code: quagga.conf.cpp in 5 places. They have for now
   been commented.
 */
/*
 * Set db value and merge variables into existing keys matched by a regexp.
 * The format of 'arg' is a 2-element string array, separated by ';'.
 *  arg[0] is the normal cli_set() format.
 *  arg[1] is the regexp key format and variables to be merges into matching keys;
 * Example specification to cligen:
 *      (string)"router.bgp $as;^router\\.bgp\\..*[^(.n)]$ $as"
 */ 
int
cli_set_tree(clicon_handle h, cvec *vars, cg_var *argv)
{
    int             npairs;
    struct db_pair *pairs;
    int             nvec;
    char          **vec;
    char           *treefmt;
    char           *setfmt = NULL;
    char           *treerx = NULL;
    char           *keyrx;
    cg_var         *cv = NULL; 
    char           *candidate_db;
    struct db_spec *dbspec;
    
    candidate_db = clicon_candidate_db(h);
    dbspec = clicon_dbspec_key(h);
    if (cv_type_get(argv) != CGV_STRING) {
	cligen_output(stderr, "Invalid type input to callback\n");
	return 0;
    }

    if ((vec = clicon_strsplit(cv_string_get(argv), ";", &nvec, __FUNCTION__)) == NULL) {
	cligen_output(stderr, "Failed to split argument\n");
	goto done;
    }
    if (nvec >= 1)
	setfmt = vec[0];
    if (nvec >= 2)
	treerx = vec[1];
    
    /* Set basic key */
    if (setfmt && strlen(setfmt)) {
	if ((cv = cv_new(CGV_STRING)) == NULL){
	    cligen_output(stderr, "Allocating cligen object: %s\n", strerror(errno)); 
	    goto done;
	}
	if (cv_parse(setfmt, cv) < 0) {
	    cligen_output(stderr, "Failed to parse set-formt\n");
	    goto done;
	}
	if (cli_mset(h, vars, cv) < 0) {
	    goto done;
	}
	cv_free(cv);
	cv = NULL;
    }
	    
    /* Merge variables for all keys matching reexp */
    if (treerx && strlen(treerx)) {
	
	/* Parse/format the rx key for db_regexp with the help of db_lv_op_lvec */
	if(db_lv_op_lvec(dbspec, candidate_db, treerx,
			 vars, &keyrx, NULL, __FUNCTION__) !=0 )
	    goto done;

	/* Get matching keys and merge variables into them */
	npairs = db_regexp(candidate_db, keyrx, __FUNCTION__, &pairs, 0);
	unchunk(keyrx);
	while(npairs-- > 0) {
	    treefmt = chunk_sprintf(__FUNCTION__, "%s%s",
				    pairs[npairs].dp_key,
				    treerx + strcspn(treerx, " \t"));
	    if (treefmt) {
		if ((cv = cv_new(CGV_STRING)) == NULL){
		    cligen_output(stderr, "Allocating cligen object: %s\n", strerror(errno)); 
		    goto done;
		}
		if (cv_parse(treefmt, cv) < 0) { 
		    cligen_output(stderr, "Failed to parse tree-formt\n");
		    goto done;
		}
		if (cli_merge(h, vars, cv) < 0) {
		    goto done;
		}
		cv_free(cv);
		cv = NULL;
	    }
	}
    }
    
done:
    if (cv)
	cv_free(cv);
    unchunk_group(__FUNCTION__);	
    return 0;
}
#endif

/*
 * cli_del_tree - Delete tree of keys from database. Unique variables
 * in keys will be taken into account.
 *
 * 
 */
int
cli_del_tree(clicon_handle h, cvec *vars, cg_var *arg)
{
    char *key;
    char *ptr;
    char *opcmd;
    int retval = -1;
    cg_var *cv; 

    key = chunkdup(cv_string_get(arg), strlen(cv_string_get(arg))+1, __FUNCTION__);
    if (key == NULL) {
	clicon_err(OE_UNIX, errno, "chunk");
	goto done;
    }
    for (ptr = key; !isspace(*ptr); ptr++)
	/* Do nothing */ ;
    *ptr++ = '\0';

    /* First remove all child keys */
    if ((opcmd = chunk_sprintf(__FUNCTION__, "^%s..*$ %s", key, ptr)) == NULL) {
	clicon_err(OE_UNIX, errno, "chunk");
	goto done;
    }

    if ((cv = cv_new(CGV_STRING)) == NULL){
	clicon_err(OE_UNIX, errno, "Allocating cligen object"); 
	goto done;
    }
    if(cv_parse(opcmd, cv) < 0) { 
	clicon_err(OE_CFG, errno, "cv_parse");
	cv_free(cv);
	goto done;
    }
    retval = cli_del(h, vars, cv);
    cv_free(cv);
   
    if (retval >= 0)
	retval = cli_del(h, vars, arg);
    
done:
    unchunk_group(__FUNCTION__);

    return retval;
}


/*
 * View db contents based on lvmap.
 */
int
cli_show_lvmap(char *dbname, struct lvmap *lmap)
{
  int res = -1;
  FILE *f = NULL;
  char buf[1024];

  if ((f = tmpfile()) == NULL) {
    clicon_err(OE_UNDEF, errno, "tmpfile: %s", strerror (errno));
    return -1;
  }
  
  if (lvmap_print(f, dbname, lmap, NULL) < 0)
    goto catch;

  /* Now send contents of file to cligen_output via cli_output_cb() */
  rewind(f);
  while(fgets(buf, sizeof(buf), f))
    cli_output_cb(buf);
  
  res = 0;

 catch:
  if (f)
    fclose(f);
  return res;
}

/*
 * cli_debug
 * set debug level on stderr (not syslog).
 * The level is either what is specified in arg as int argument.
 * _or_ if a 'level' variable is present in vars use that value instead.
 */
int
cli_debug(clicon_handle h, cvec *vars, cg_var *arg)
{
    cg_var *cv;
    int     level;
    char   *s;

    if ((cv = cvec_find_var(vars, "level")) == NULL)
	cv = arg;
    level = cv_int_get(cv);
    /* cli */
    clicon_debug_init(level, NULL); /* 0: dont debug, 1:debug */
    /* config daemon */
    if ((s = clicon_sock(h)) == NULL)
	goto done;
    if (cli_proto_debug(s, level) < 0)
	goto done;
  done:
    return 0;
}


void
cli_signal_block(void)
{
	clicon_signal_block (SIGTSTP);
	clicon_signal_block (SIGQUIT);
	clicon_signal_block (SIGCHLD);
	clicon_signal_block (SIGINT);
}

void
cli_signal_unblock(void)
{
	clicon_signal_unblock (SIGTSTP);
	clicon_signal_unblock (SIGQUIT);
	clicon_signal_unblock (SIGCHLD);
	clicon_signal_unblock (SIGINT);
}

/*
 * Flush pending signals for a given signal type
 */
void
cli_signal_flush()
{
    /* XXX A bit rough. Use sigpending() and more clever logic ?? */

    sigfn_t   h1, h2, h3, h4;

    set_signal (SIGTSTP, SIG_IGN, &h1);
    set_signal (SIGQUIT, SIG_IGN, &h2);
    set_signal (SIGCHLD, SIG_IGN, &h3);
    set_signal (SIGINT, SIG_IGN, &h4);

    cli_signal_unblock ();

    set_signal (SIGTSTP, h1, NULL);
    set_signal (SIGQUIT, h2, NULL);
    set_signal (SIGCHLD, h3, NULL);
    set_signal (SIGINT, h4, NULL);

    cli_signal_block ();
}


/* Code for recording which CLI commands have been issued */

static FILE *_recordf = NULL;
static int _isrecording = 0;

int
isrecording(void)
{
    return _isrecording;
}

int
cli_record(clicon_handle h, cvec *vars, cg_var *arg)
{
    _isrecording = cv_int_get(arg);
    return 0;
}

static int
record_open(void)
{
    char file[] = "/tmp/cli.record.XXXXXX";
    int fd;

    if ((fd = mkstemp(file)) < 0 || (_recordf = fdopen(fd, "w")) < 0) {
	clicon_err(OE_UNIX, errno, "mkstemp/fdopen");
	return -1;
    }
    return 0;
}

/*
 * record commands in file
 */
int
record_command(char *str)
{
    if (_recordf==NULL)
	if (record_open() < 0)
	    return -1;
    fprintf(_recordf, "%s\n", str);
    fflush(_recordf);
    return 0;
}


/*
 * Callback to set syntax mode
 */
int
cli_set_mode(clicon_handle h, cvec *vars, cg_var *arg)
{
    cli_set_syntax_mode(h, cv_string_get(arg));
    return 0;
}

/*
 * XXX Application specific??
 * cli_start_shell
 * Start bash from cli callback
 */ 
int
cli_start_shell(clicon_handle h, cvec *vars, cg_var *arg)
{
    char *cmd;
    struct passwd *pw;
    int retval;
    char bcmd[128];
    cg_var *cv1 = cvec_i(vars, 1);

    cmd = (cvec_len(vars)>1 ? cv_string_get(cv1) : NULL);

    if ((pw = getpwuid(getuid())) == NULL){
	fprintf(stderr, "%s: getpwuid: %s\n", 
		__FUNCTION__, strerror(errno));
	return -1;
    }
    if (chdir(pw->pw_dir) < 0){ 
	fprintf(stderr, "%s: chdir(%s): %s\n",
		__FUNCTION__, pw->pw_dir, strerror(errno));
	endpwent();
	return -1;
    }
    endpwent();
    cli_signal_flush();
    cli_signal_unblock();
    if (cmd){
	snprintf(bcmd, 128, "bash -c \"%s\"", cmd);
	if ((retval = system(bcmd)) < 0){
	    cli_signal_block();
	    fprintf(stderr, "%s: system(bash -c): %s\n", 
		    __FUNCTION__, strerror(errno));
	    return -1;
	}
    }
    else
	if ((retval = system("bash")) < 0){
	    cli_signal_block();
	    fprintf(stderr, "%s: system(bash): %s\n", 
		    __FUNCTION__, strerror(errno));
	    return -1;
	}
    cli_signal_block();
#if 0 /* Allow errcodes from bash */
    if (retval != 0){
	fprintf(stderr, "%s: system(%s) code=%d\n", __FUNCTION__, cmd, retval);
      return -1;
    }
#endif

    return 0;
}

/*
 * Generic quit callback
 */
int 
cli_quit(clicon_handle h, cvec *vars, cg_var *arg)
{
    cli_set_exiting(h, 1);
    return 0;
}

/*
 * Generic commit callback
 * if arg is 1, then snapshot and copy to startup config
 */
int
cli_commit(clicon_handle h, cvec *vars, cg_var *arg)
{
    char          *s;
    int            snapshot = arg?cv_int_get(arg):0;

    if ((s = clicon_sock(h)) == NULL)
	return -1;
    return cli_proto_commit(s, 
			    clicon_running_db(h), 
			    clicon_candidate_db(h), 
			    snapshot, /* snapshot */
			    snapshot); /* startup */
}

/*
 * Generic validatecallback
 */
int
cli_validate(clicon_handle h, cvec *vars, cg_var *arg)
{
    char          *s;

    if ((s = clicon_sock(h)) == NULL)
	return -1;
    return cli_proto_validate(s, clicon_candidate_db(h));
}


/*
 * expand_dbvar
 * Expand based on database key and variable value (of that key)
 * Return an expand-type list of commands as used by cligen 'expand' 
 * functionality.
 * arg is a string: "<dbname> <keypattern> <variable>". 
 *   <dbname> is either running or candidate
 *   <keypattern> matches a set of database keys
 *   <variable>   is name of a variable occuring in the cli command string
 * Example: "candidate ^Create.*$" GroupName"
 * (See also expand_db_variable(). But this is more generic and can be called
 * as cligen callback)
 *
 * Assume callback given in a cligen spec: a <x:int expand_dbvar_auto("arg")
 * IN:
 *   h        clicon handle 
 *   name     Name of this function (eg "expand_dbvar")
 *   cvec     The command so far. Eg: cvec [0]:"a 5 b"; [1]: x=5;
 *   arg      Argument given at the callback ("arg")
 * OUT:
 *   len      len of return commands & helptxt 
 *   commands vector of function pointers to callback functions
 *   helptxt  vector of pointers to helptexts
 */
int
expand_dbvar(void *h, char *name, cvec *vars, cg_var *arg, 
	     int *nr, char ***commands, char ***helptexts)
{
    char  *dbname;
    int    nvec;
    char **vec = NULL;
    int    retval = -1;
    char  *str;
    char  *dbstr, *keystr, *varstr;  

    if (arg == NULL)
	return -1;
    if ((str = cv_string_get(arg)) == NULL)
	return -1;
    if ((vec = clicon_strsplit(cv_string_get(arg), " ", &nvec, __FUNCTION__)) == NULL){
	clicon_err(OE_PLUGIN, errno, "clicon_strsplit");	
	goto done;
    }
    if (nvec != 3){
	clicon_err(OE_PLUGIN, 0, "format error \"%s\" - expected <dbname> <key> <variable>",
	    str);	
	goto done;
    }
    dbstr  = vec[0];
    keystr = vec[1];
    varstr = vec[2];
    if (strcmp(dbstr, "running") == 0) 
	dbname = clicon_running_db(h);
    else
    if (strcmp(dbstr, "candidate") == 0) 
	dbname = clicon_candidate_db(h);
    else{
	clicon_err(OE_PLUGIN, 0, "No such db name: %s", dbstr);	
	goto done;
    }

    if ((retval = expand_db_variable(h, dbname, keystr, varstr, nr, commands)) < 0)
	goto done;
    retval = 0;
  done:
    unchunk_group(__FUNCTION__);
    return retval;
}


/*
 * expand_dbvar_auto
 * Completion callback primarilyintended for automatically generated data model
 * code. 
 * Returns an expand-type list of commands as used by cligen 'expand' 
 * functionality.
 * arg is a string: "<dbname> <keypattern> <variable>". 
 *   <dbname> is either running or candidate
 *   <pattern> matches a set of database keys following clicon_dbspec. 
 *             Eg a[].b[] $!x $!y
 *             the last being the variable to expand for.
 * Example:
 * dbspec is a[].b[] $!x $!y
 * clispec is a <x> b (<y>|<y expand_dbvar_auto()>;
 * db contains entries:
 * a.0 $x=5
 * a.1 $x=10
 * a.0.b.0 $x=5 $y=12
 * a.0.b.1 $x=5 $y=20
 * a.1.b.0 $x=10 $y=99
 *
 * The user types a 5 b <?> which produces the following output:
 *   <int>
 *   12
 *   20
 *
 * Assume callback given in a cligen spec: a <x:int expand_dbvar_auto("arg")
 * IN:
 *   h        clicon handle 
 *   name     Name of this function (eg "expand_dbvar-auto")
 *   cvec     The command so far. Eg: cvec [0]:"a 5 b"; [1]: x=5;
 *   arg      Argument given at the callback ("arg")
 * OUT:
 *   len      len of return commands & helptxt 
 *   commands vector of function pointers to callback functions
 *   helptxt  vector of pointers to helptexts
 */
int
expand_dbvar_auto(void *h, char *name, cvec *cvec, cg_var *arg, 
		  int *nr, char ***commands, char ***helptexts)
{
    char            *dbname;
    int              nvec;
    char           **vec = NULL;
    int              retval = -1;
    char            *str;
    char            *dbstr;  
    char            *rest;
    char            *last;
    struct db_spec  *spec;
    clicon_dbvars_t *dbv = NULL;
    cg_var          *cv;

    if (arg == NULL)
	return -1;
    /* In the example, str = "candidate a[].b[] $!x $!y" */
    if ((str = cv_string_get(arg)) == NULL)
	return -1;
    if ((vec = clicon_strsplit(cv_string_get(arg), " ", &nvec, __FUNCTION__)) == NULL){
	clicon_err(OE_PLUGIN, errno, "clicon_strsplit");	
	goto done;
    }
    dbstr  = vec[0];
    if (strcmp(dbstr, "running") == 0) 
	dbname = clicon_running_db(h);
    else
    if (strcmp(dbstr, "candidate") == 0) 
	dbname = clicon_candidate_db(h);
    else{
	clicon_err(OE_PLUGIN, 0, "No such db name: %s", dbstr);	
	goto done;
    }

    spec = clicon_dbspec_key(h);
    /* rest is just arg stripped of <db>. Eg "a[].b[] $!x $!y"*/
    if ((rest = index(str, ' ')) == NULL)
	goto done;
    rest++;
    /* last is the last variable in arg. Eg "y" */
    if ((last = rindex(str, ' ')) == NULL)
	goto done;
    last++;
    if (index(last, '$'))
	last++;
    if (index(last, '!'))
	last++;

    /* For the cli_se_parse() function to work, we need to add the 'last' variable
       Eg: cvec [0]:"a 5 b"; [1]: x=5; [2]: y=0;
       (Not significant the type and value of last.
     */
    if ((cv = cvec_add(cvec, CGV_INT)) == NULL) /* type not significant */
	goto done;
    cv_name_set(cv, last);
    cv_const_set(cv, 0);
    cv_int_set(cv, 0); /* not significant */

    /* Parse the arg(rest). Get back a key (eg a.0.b[]) and vec (eg !x=5) */
    if ((dbv = cli_set_parse(h, 
			spec, 
			dbname, 
			cvec,
			     rest)) == NULL)
	goto done;
    cv = cvec_i(cvec, cvec_len(cvec)-1);
    cv_reset(cv);
    cvec_del(cvec, cv);
    if (debug > 1){
	fprintf(stderr, "%s: dbv_key: %s\n", __FUNCTION__, dbv->dbv_key);
	fprintf(stderr, "dbv_vec:");
	cvec_print(stdout, dbv->dbv_vec);
    }
    /* Look up in database and return available commands (eg "12,20") */
    if ((retval = expand_db_variable(h, dbname, dbv->dbv_key, 
				     last, 
				     nr, commands)) < 0)
	goto done;
    retval = 0;
  done:

    unchunk_group(__FUNCTION__);
    if (dbv)
	clicon_dbvars_free(dbv);

    return retval;

}

/*
 * expand_db_variable
 * Given a database, a basekey (pattern) and a variable, return an expand-type
 * list of commands as used by cligen 'expand' functionality.
 * (See also expand_dbvar())
 */
int
expand_db_variable(clicon_handle h, 
		   char         *dbname,
		   char         *basekey, 
		   char         *variable, 
		   int          *nr, 
		   char       ***commands)
{
    char           *key;
    int             i;
    int             retval = -1;
    int             npairs;
    struct db_pair *pairs;
    cvec           *cvec;
    cg_var         *cv = NULL;
    char          **tmp;
    char           *buf = NULL;

    /* adhoc to detect regexp keys. If so, dont call db_gen_rxkey */
    if (index(basekey, '^') == NULL){
	if ((key = db_gen_rxkey(basekey, __FUNCTION__)) == NULL)
	    goto quit;
    }
    else
	key = chunkdup(basekey, strlen(basekey)+1, __FUNCTION__);
    
    npairs = db_regexp(dbname, key, __FUNCTION__, &pairs, 1);
    if (npairs < 0)
	goto quit;
    *nr = 0;
    for (i = 0; i < npairs; i++) {
	if ((cvec = dbkey2cvec(dbname, pairs[i].dp_key)) == NULL)
	    continue;
	cv = NULL;
	while ((cv = cvec_each(cvec, cv)) != NULL) {
	    if (strcmp(cv_name_get(cv), variable) != 0)
		continue;
	    if ((buf = cv2str_dup(cv)) == NULL)
		goto quit;
	    if ((tmp = realloc(*commands, sizeof(char *) * ((*nr)+1))) == NULL) {
		clicon_err(OE_UNDEF, errno, "realloc: %s", strerror (errno));	
		goto quit;
	    }
	    *commands = tmp;
	    (*commands)[*nr] = buf;
	    buf = NULL;
	    (*nr)++;
	}
	cvec_free(cvec);
    }
    retval = 0;
quit:
    unchunk_group(__FUNCTION__);
    return retval;
}


/*
 * expand_db_symbol
 * pattern match in candidate_db
 */
int
expand_db_symbol(clicon_handle h, 
		 char *symbol, 
		 int element, 
		 int *nr, 
		 char ***commands)
{
    char **tmp;
    struct db_pair *pairs;
    int npairs, p;
    int nvec;
    int n;
    char **vec = NULL;
    char str[128];
    
    snprintf(str, sizeof(str), "^%s\\..", symbol);
    if ((npairs = db_regexp(clicon_running_db(h), str, __FUNCTION__, &pairs, 0)) < 0)
	return -1;
    for (p=0; p<npairs; p++){
	if ((vec = clicon_strsplit(pairs[p].dp_key, ".", &nvec, __FUNCTION__)) == NULL){
	    clicon_err(OE_UNDEF, errno, "clicon_strsplit");	
	    goto catch;
	}
	/* Check if already exists */
	for (n=0; n<*nr; n++)
	    if (strcmp((*commands)[n], vec[element]) == 0)
		break; /* Already exists */
	if (n<*nr)
	    continue;
	/* Allocate new pointer */
	if ((tmp = realloc(*commands, sizeof(char *) * ((*nr)+1))) == NULL) {
	    clicon_err(OE_UNDEF, errno, "realloc: %s", strerror (errno));	
	    goto catch;
	}
	*commands = tmp;
	/* Duplicate string */
	if (((*commands)[*nr] = strdup(vec[element])) == NULL) {
	    clicon_err(OE_UNDEF, errno, "strdup: %s", strerror (errno));	
	    goto catch;
	}
	(*nr)++;
    }
    unchunk_group(__FUNCTION__) ;
    return 0;
 catch:
  unchunk_group(__FUNCTION__) ;
  while ((*nr) >= 0)
    free((*commands)[(*nr)--]);
  free (*commands);
  return -1;
}

/*
 * expand_dir
 * List files in a directory
 */
int
expand_dir(char *dir, int *nr, char ***commands, mode_t flags, int detail)
{
    DIR	*dirp;
    struct dirent *dp;
    struct stat st;
    char *str;
    char *cmd;
    int len;
    int retval = -1;
    struct passwd *pw;
    char filename[MAXPATHLEN];

    if ((dirp = opendir(dir)) == 0){
	fprintf(stderr, "expand_dir: opendir(%s) %s\n", 
		dir, strerror(errno));
	return -1;
    }
    *nr = 0;
    while ((dp = readdir(dirp)) != NULL) {
	if (
#if 0
	    strcmp(dp->d_name, ".") != 0 &&
	    strcmp(dp->d_name, "..") != 0
#else
	    dp->d_name[0] != '.'
#endif	    
	    ) {
	    snprintf(filename, MAXPATHLEN-1, "%s/%s", dir, dp->d_name);
	    if (lstat(filename, &st) == 0){
		if ((st.st_mode & flags) == 0)
		    continue;

#if EXPAND_RECURSIVE
		if (S_ISDIR(st.st_mode)) {
		    int nrsav = *nr;
		    if(expand_dir(filename, nr, commands, detail) < 0)
			goto quit;
		    while(nrsav < *nr) {
			len = strlen(dp->d_name) +  strlen((*commands)[nrsav]) + 2;
			if((str = malloc(len)) == NULL) {
			    fprintf(stderr, "expand_dir: malloc: %s\n",
				    strerror(errno));
			    goto quit;
			}
			snprintf(str, len-1, "%s/%s",
				 dp->d_name, (*commands)[nrsav]);
			free((*commands)[nrsav]);
			(*commands)[nrsav] = str;
			
			nrsav++;
		    }
		    continue;
		}
#endif
		if ((cmd = strdup(dp->d_name)) == NULL) {
		    fprintf(stderr, "expand_dir: strdup: %s\n",
			    strerror(errno));
		    goto quit;
		}
		if (0 &&detail){
		    if ((pw = getpwuid(st.st_uid)) == NULL){
			fprintf(stderr, "expand_dir: getpwuid(%d): %s\n",
				st.st_uid, strerror(errno));
			goto quit;
		    }
		    len = strlen(cmd) + 
			strlen(pw->pw_name) +
#ifdef __FreeBSD__
			strlen(ctime(&st.st_mtimespec.tv_sec)) +
#else
			strlen(ctime(&st.st_mtim.tv_sec)) +
#endif

			strlen("{ by }") + 1 /* \0 */;
		    if ((str=realloc(cmd, strlen(cmd)+len)) == NULL) {
			fprintf(stderr, "expand_dir: malloc: %s\n",
				strerror(errno));
			goto quit;
		    }
		    snprintf(str + strlen(dp->d_name), 
			     len - strlen(dp->d_name),
			     "{%s by %s}",
#ifdef __FreeBSD__
			     ctime(&st.st_mtimespec.tv_sec),
#else
			     ctime(&st.st_mtim.tv_sec),
#endif

			     pw->pw_name
			);
		    cmd = str;
		}
		if (((*commands) =
		     realloc(*commands, ((*nr)+1)*sizeof(char**))) == NULL){
		    perror("expand_dir: realloc");
		    goto quit;
		}
		(*commands)[(*nr)] = cmd;
		(*nr)++;
		if (*nr >= 128) /* Limit number of options */
		    break;
	    }
	}
	
    }

    retval = 0;
  quit:
    closedir(dirp);
    return retval;
}


/*
 * Compare two dbs using XML
 */
static int
compare_xmls(struct xml_node *xc1, struct xml_node *xc2, int astext)
{
    int fd;
    FILE *f;
    char filename1[MAXPATHLEN];
    char filename2[MAXPATHLEN];
    char cmd[MAXPATHLEN];
    int retval = -1;
    struct xml_node *xc;

    snprintf(filename1, sizeof(filename1), "/tmp/cliconXXXXXX");
    snprintf(filename2, sizeof(filename2), "/tmp/cliconXXXXXX");
    if ((fd = mkstemp(filename1)) < 0){
	clicon_err(OE_UNDEF, errno, "tmpfile: %s", strerror (errno));
	goto done;
    }
    if ((f = fdopen(fd, "w")) == NULL)
	goto done;
    xc = NULL;
    if (astext)
	while ((xc = xml_child_each(xc1, xc, -1)) != NULL)
	    xml2txt(f, xc, 0);
    else
	while ((xc = xml_child_each(xc1, xc, -1)) != NULL)
	    xml_to_file(f, xc, 0, 1);

    fclose(f);
    close(fd);

    if ((fd = mkstemp(filename2)) < 0){
	clicon_err(OE_UNDEF, errno, "tmpfile: %s", strerror (errno));
	goto done;
    }
    if ((f = fdopen(fd, "w")) == NULL)
	goto done;
    xc = NULL;
    if (astext)
	while ((xc = xml_child_each(xc2, xc, -1)) != NULL)
	    xml2txt(f, xc, 0);
    else
	while ((xc = xml_child_each(xc2, xc, -1)) != NULL)
	    xml_to_file(f, xc, 0, 1);
    fclose(f);
    close(fd);

    snprintf(cmd, sizeof(cmd), "/usr/bin/diff -dU 1 %s %s |  grep -v @@ | sed 1,2d", 		 filename1, filename2);
    if (system(cmd) < 0)
	goto done;

    retval = 0;
  done:
    unlink(filename1);
    unlink(filename2);
    return retval;
}

/*
 * compare_dbs
 * using XML
 * arg: 0 as xml, 1: as xml
 */
int
compare_dbs(clicon_handle h, cvec *vars, cg_var *arg)
{
    struct xml_node *xc1 = NULL; /* running xml */
    struct xml_node *xc2 = NULL; /* candidate xml */
    int retval = -1;

    if ((xc1 = db2xml(clicon_running_db(h), clicon_dbspec_key(h), "dbr")) == NULL)
	goto done;
    if ((xc2 = db2xml(clicon_candidate_db(h), clicon_dbspec_key(h), "dbc")) == NULL)
	goto done;

    if (compare_xmls(xc1, xc2, arg?cv_int_get(arg):0) < 0) /* astext? */
	goto done;
    retval = 0;
  done:
    if (xc1)
	xml_free(xc1);    
    if (xc2)
	xml_free(xc2);

    return retval;
}


/*
 * cli_show_diff
 * Display the differences between two databases based on an
 * application specified lvmap.
 */
int
cli_show_diff(clicon_handle h, char *db1, char *db2, struct lvmap *lmap)
{
    int ret;
    int  retval = -1;
    char *cmd;
    char *tmp1 = NULL;
    char *tmp2 = NULL;
    FILE *f1 = NULL;
    FILE *f2 = NULL;

    /* dump db1 to file */
    if ((tmp1 = clicon_tmpfile(__FUNCTION__)) == NULL)
	goto quit;
    if ((f1 = fopen(tmp1, "w")) == NULL){
	clicon_err(OE_UNIX, errno, "fopen");
	goto quit;
    }
    ret = lvmap_print(f1, db1, lmap, NULL);
    fclose(f1);
    if (ret < 0)
	goto quit;

    /* dump db2 to file */
    if ((tmp2 = clicon_tmpfile(__FUNCTION__)) == NULL)
	goto quit;
    if ((f2 = fopen(tmp2, "w")) == NULL){
	clicon_err(OE_UNIX, errno, "fopen");
	goto quit;
    }
    ret = lvmap_print(f2, db2, lmap, NULL);
    fclose(f2);
    if (ret < 0)
	goto quit;

    /* diff candidate with snapshot */
    cmd = chunk_sprintf(__FUNCTION__,
			"/usr/bin/diff -dU 1 %s %s | grep -v @@ | sed 1,2d", 
			tmp1, tmp2);
    if (cmd == NULL) {
	clicon_err(OE_UNIX, errno, "chunk");
	goto quit;
    }
    if (system(cmd) < 0)
	goto quit;
    
    retval = 0;
quit:
    
    if (tmp1)
	unlink(tmp1);
    if (tmp2)
	unlink(tmp2);
    unchunk_group(__FUNCTION__);
    return retval;
}


/*
 * cli_downcall
 * Call a config function
 */
int
cli_downcall(clicon_handle h, uint16_t op, char *plugin, char *func,
	     void *param, uint16_t paramlen, 
	     char **ret, uint16_t *retlen,
	     const void *label
    )
{
    struct clicon_msg *msg;
    char *s;
    int retval = -1;

    if ((msg = clicon_msg_call_encode(op, plugin, func, 
				      paramlen, param, 
				      label)) == NULL)
	goto done;
    if ((s = clicon_sock(h)) == NULL)
	goto done;
    if (clicon_rpc_connect(msg, s, (char**)ret, retlen, label) < 0)
	goto done;
    retval = 0;
done:
    return retval;
}


/* New cli_set/del code */
static int 
cli_dbop(clicon_handle h, cvec *vars, cg_var *arg, lv_op_t op)
{
    char            *s;
    char            *candidate;
    char            *running;
    struct db_spec  *spec;
    clicon_dbvars_t *dbv;
    int	             retval = -1;

    candidate = clicon_candidate_db(h);
    running   = clicon_running_db(h);
    spec = clicon_dbspec_key(h);
    
    if ((s = clicon_sock(h)) == NULL)
	return -1;

    dbv = cli_set_parse(h, spec, candidate, vars, 
			arg?cv_string_get(arg):""); 
    if (dbv == NULL)
	return -1;

    if (cli_usedaemon(h)) {
	if (cli_proto_change_cvec(h, candidate, op, dbv->dbv_key, dbv->dbv_vec) < 0)
	    goto quit;
    } else {
	if (db_lv_op_exec(spec, candidate, dbv->dbv_key, op, dbv->dbv_vec) < 0)
	    goto quit;
    }

    if (cli_usedaemon(h) && clicon_autocommit(h)) {
        if (cli_proto_commit(s, running, candidate, 0, 0) < 0) {
	    if (cli_proto_copy(s, running, candidate) < 0)
	        fprintf(stderr, "Failed to restore candidate: %s\n", 
			strerror(errno));
	    goto quit;
	}
    }

    retval = 0;
quit:
    clicon_dbvars_free(dbv);

    return retval;}


int 
cli_set(clicon_handle h, cvec *vars, cg_var *arg)
{
    return cli_dbop(h, vars, arg, LV_SET);
}

int 
cli_merge(clicon_handle h, cvec *vars, cg_var *arg)
{
    return cli_dbop(h, vars, arg, LV_MERGE);
}

int 
cli_del(clicon_handle h, cvec *vars, cg_var *arg)
{
    return cli_dbop(h, vars, arg, LV_DELETE);
}


/*
 * load_config_file
 * Load a configuration file to candidate database
 * arg is a string: "<varname> <op>" 
 *   <varname> is name of a variable occuring in the cligen command string.
 *   <op> is either "merge" or "replace"
 * Example (cligen spec): 
 *   load file <name2:string>, load_config_file("name2 merge");
 */
int 
load_config_file(clicon_handle h, cvec *vars, cg_var *arg)
{
    int         ret = -1;
    struct stat st;
    char      **vec;
    char      **vecp;
    char       *filename;
    int         replace;
    char       *s;
    char       *dbname;
    char       *str;
    cg_var     *cv;
    int         nvec;
    char       *opstr;
    char       *varstr;

    if (arg == NULL)
	goto catch;
    str = cv_string_get(arg);
    if ((vec = clicon_strsplit(str, " ", &nvec, __FUNCTION__)) == NULL){
	clicon_err(OE_PLUGIN, errno, "clicon_strsplit");	
	goto catch;
    }
    if (nvec != 2){
	clicon_err(OE_PLUGIN, 0, "Arg syntax is <varname> <replace|merge>");	
	goto catch;
    }
    varstr = vec[0];
    opstr  = vec[1];
    if (strcmp(opstr, "merge") == 0) 
	replace = 0;
    else
    if (strcmp(opstr, "replace") == 0) 
	replace = 1;
    else{
	clicon_err(OE_PLUGIN, 0, "No such op: %s, expected merge or replace", opstr);	
	goto catch;
    }
    if ((cv = cvec_find_var(vars, varstr)) == NULL){
	clicon_err(OE_PLUGIN, 0, "No such var name: %s", varstr);	
	goto catch;
    }
    if ((vecp = clicon_realpath(NULL, cv_string_get(cv), __FUNCTION__)) == NULL){
	cli_output(stderr, "Failed to resolve filename\n");
	goto catch;
    }
    filename = vecp[0];
    dbname = clicon_candidate_db(h);
    if (stat(filename, &st) < 0){
 	fprintf(stderr, "load_config: stat(%s): %s\n", 
 		filename, strerror(errno));
	goto catch;
    }
    if ((s = clicon_sock(h)) == NULL)
	return -1;
    if (cli_proto_load(s, replace, dbname, filename) < 0)
	goto catch;

    ret = 0;
  catch:
    return ret;
}

/*
 * save_config_file
 * Copy db to file Argument is database
 * arg is a string: "<dbname> <varname>" 
 *   <dbname>  is running or candidate
 *   <varname> is name of cligen variable in the cligen string.
 * Example (cligen spec): 
 *   save file <name:string>, save_config_file("running name");
 */
int
save_config_file(clicon_handle h, cvec *vars, cg_var *arg)
{
    int        retval = -1;
    char      *s;
    char     **vec;
    char     **vecp;
    char      *filename;
    char      *dbname;
    cg_var    *cv;
    int        nvec;
    char      *str;
    char      *dbstr;
    char      *varstr;

    if (arg == NULL)
	goto catch;
    str = cv_string_get(arg);
    if ((vec = clicon_strsplit(str, " ", &nvec, __FUNCTION__)) == NULL){
	clicon_err(OE_PLUGIN, errno, "clicon_strsplit");	
	goto catch;
    }
    if (nvec != 2){
	clicon_err(OE_PLUGIN, 0, "Arg syntax is <dbname> <varname>");	
	goto catch;
    }
    dbstr  = vec[0];
    varstr = vec[1];
    if (strcmp(dbstr, "running") == 0) 
	dbname = clicon_running_db(h);
    else
    if (strcmp(dbstr, "candidate") == 0) 
	dbname = clicon_candidate_db(h);
    else{
	clicon_err(OE_PLUGIN, 0, "No such db name: %s", dbstr);	
	goto catch;
    }
    if ((cv = cvec_find_var(vars, varstr)) == NULL){
	clicon_err(OE_PLUGIN, 0, "No such var name: %s", varstr);	
	goto catch;
    }
    if ((vecp = clicon_realpath(NULL, cv_string_get(cv), __FUNCTION__)) == NULL){
	cli_output(stderr, "Failed to resolve filename\n");
	goto catch;
    }
    filename = vecp[0];

    if ((s = clicon_sock(h)) == NULL)
	return -1;
  
    if (cli_proto_save(s, dbname, 0, filename) < 0) /*  */
	goto catch;
    retval = 0;
    /* Fall through */
  catch:
    unchunk_group(__FUNCTION__);
    return retval;
}

int
delete_all(clicon_handle h, cvec *vars, cg_var *arg)
{
    char            *s;
    char            *dbname;
    char            *dbstr;
    int              retval = -1;

    if (arg == NULL)
	return -1;
    dbstr = cv_string_get(arg);
    if (strcmp(dbstr, "running") == 0) 
	dbname = clicon_running_db(h);
    else
    if (strcmp(dbstr, "candidate") == 0) 
	dbname = clicon_candidate_db(h);
    else{
	clicon_err(OE_PLUGIN, 0, "No such db name: %s", dbstr);	
	goto catch;
    }
    if ((s = clicon_sock(h)) == NULL)
	goto catch;
    cli_proto_rm(s, dbname);
    cli_proto_initdb(s, dbname);
    retval = 0;
  catch:
    return retval;
}

int
discard_changes(clicon_handle h, cvec *vars, cg_var *arg)
{
    char *s;
    char *running_db = clicon_running_db(h);
    char *candidate_db = clicon_candidate_db(h);

    s = clicon_sock(h);
    cli_proto_copy(s, running_db, candidate_db);
    return 0;
}


/*
 * show_conf_as
 * Generic function for showing configurations.
 * the callback differs.
 * arg is a string: <dbname> <key> [<variable> <varname>]. 
 *   <dbname> is either running or candidate
 *   <key> is a database key or ~.*$ for all
 *   <variable> if given, then a match is made with a cv called <varname>
 * Example (cligen spec): 
 *   show config id <n:string>, show_conf_as("running ^MPoint.*$ Name n");
 */
static int
show_conf_as(clicon_handle h, cvec *vars, cg_var *arg, 
	     dbmatch_fn_t fn, void *fnarg)
{
    struct xml_node *x0 = NULL; /* top xml */
    char            *regex;
    int              retval = -1;
    cg_var          *cv;
    char            *dbname;
    char            *attr = NULL;
    char            *val = NULL;
    char            *valname;
    char           **vec = NULL;
    int              nvec;
    char            *str;
    int              len;
    int              i;
    char           **keyv;
    cvec           **cvecv;

    str = cv_string_get(arg);
    if ((vec = clicon_strsplit(str, " ", &nvec, __FUNCTION__)) == NULL){
	clicon_err(OE_PLUGIN, errno, "clicon_strsplit");	
	goto catch;
    }
    if (nvec != 2 && nvec != 4){
	clicon_err(OE_PLUGIN, 0, "format error \"%s\" - expected <dbname> <key> [<name> <variable>]", str);	
	goto catch;
    }
    if (nvec > 2){
	attr = vec[2];
	valname = vec[3];
	cv = cvec_find_var(vars, valname);
	if (cv && (val = cv2str_dup(cv)) == NULL)
	    goto catch;
    }
    /* Dont get attr here, take it from arg instead */
    if (strcmp(vec[0], "running") == 0) /* XXX: hardcoded */
	dbname = clicon_running_db(h);
    else
    if (strcmp(vec[0], "candidate") == 0) /* XXX: hardcoded */
	dbname = clicon_candidate_db(h);
    else{
	clicon_err(OE_PLUGIN, 0, "No such db name: %s", vec[0]);	
	goto catch;
    }
    regex = vec[1];
    if (dbmatch_vec(h, dbname, regex, attr, val, &keyv, &cvecv, &len) < 0)
	goto catch;
    for (i=0; i<len; i++)
	if ((*fn)(h, dbname, keyv[i], cvecv[i], fnarg) < 0)
	    goto catch;
    dbmatch_vec_free(keyv, cvecv, len);
    retval = 0;
catch:
    unchunk_group(__FUNCTION__);
    if (x0)
	xml_free(x0);
    if (val)
	free(val);
    return retval;

}

/* callback used by show_conf_* just to merge xml */
static int
add2xml_cb(void *handle, char *dbname, char *key, cvec *vr, void *arg)
{
    struct xml_node *xt;

    xt = (struct xml_node*)arg;
    return key2xml(key, dbname, clicon_dbspec_key(handle), xt);
}

/*
 * Show a configuration database on stdout using XML format
 * 
 */
static int
show_conf_as_xml1(clicon_handle h, cvec *vars, cg_var *arg, int netconf)
{
    struct xml_node *xt = NULL;
    struct xml_node *xc;
    int              retval = -1;

    if ((xt = xml_new("tmp", NULL)) == NULL)
	goto catch;
    if (show_conf_as(h, vars, arg, add2xml_cb, xt) < 0)
	goto catch;
    if (netconf) /* netconf prefix */
	fprintf(stdout, "<rpc><edit-config><target><candidate/></target><config>\n");
    xc = NULL; /* Dont print xt itself */
    while ((xc = xml_child_each(xt, xc, -1)) != NULL)
	xml_to_file(stdout, xc, netconf?2:0, 1);
    if (netconf) /* netconf postfix */
	fprintf(stdout, "</config></edit-config></rpc>]]>]]>\n");
    retval = 0;
  catch:
    if (xt)
	xml_free(xt);
    return retval;

}

int
show_conf_as_xml(clicon_handle h, cvec *vars, cg_var *arg)
{
    return show_conf_as_xml1(h, vars, arg, 0);
}

int
show_conf_as_netconf(clicon_handle h, cvec *vars, cg_var *arg)
{
    return show_conf_as_xml1(h, vars, arg, 1);
}

/*
 * show_conf_as_text1
 * as_cmd: as command, ie not tree format but as one-line commands
 */
static int
show_conf_as_text1(clicon_handle h, cvec *vars, cg_var *arg, int as_cmd)
{
    struct xml_node *xt = NULL;
    struct xml_node *xc;
    enum genmodel_type gt;
    int                retval = -1;

    if ((xt = xml_new("tmp", NULL)) == NULL)
	goto catch;
    if (show_conf_as(h, vars, arg, add2xml_cb, xt) < 0)
	goto catch;

    xc = NULL; /* Dont print xt itself */
    while ((xc = xml_child_each(xt, xc, -1)) != NULL)
	if (as_cmd){
	    if ((gt = clicon_cli_genmodel_type(h)) == GT_ERR)
		goto catch;
	    xml2cli(stdout, xc, NULL, gt, __FUNCTION__); /* cli syntax */
	}
	else
	    xml2txt(stdout, xc, 0); /* tree-formed text */
    retval = 0;
  catch:
    if (xt)
	xml_free(xt);
    unchunk_group(__FUNCTION__);
    return retval;
}



int
show_conf_as_text(clicon_handle h, cvec *vars, cg_var *arg)
{
    return show_conf_as_text1(h, vars, arg, 0);
}

int
show_conf_as_cli(clicon_handle h, cvec *vars, cg_var *arg)
{
    return show_conf_as_text1(h, vars, arg, 1);
}

static int
cli_notification_cb(int s, void *arg)
{
    struct clicon_msg *reply;
    int                eof;
    int                retval = -1;
    char              *event = NULL;
    int                level;

    /* get msg (this is the reason this function is called) */
    if (clicon_msg_rcv(s, &reply, &eof, __FUNCTION__) < 0)
	goto done;
    if (eof){
	clicon_err(OE_PROTO, ESHUTDOWN, "%s: Socket unexpected close", __FUNCTION__);
	close(s);
	errno = ESHUTDOWN;
	event_unreg_fd(s, cli_notification_cb);
	goto done;
    }
    switch (reply->op_type){
    case CLICON_MSG_NOTIFY:
	if (clicon_msg_notify_decode(reply, &level, &event, __FUNCTION__) < 0) 
	    goto done;
	fprintf(stderr, "%s\n", event);
	break;
    default:
	clicon_err(OE_PROTO, 0, "%s: unexpected reply: %d", 
		__FUNCTION__, reply->op_type);
	goto done;
	break;
    }
    retval = 0;
  done:
    unchunk_group(__FUNCTION__); /* event allocated by chunk */
    return retval;

}

/*!
 * \brief send a notify subscription to backend and register callback for return messages.
 */
int
cli_getlog(clicon_handle h, cvec *vars, cg_var *arg)
{
    char            *sockpath;
    int              s;
    char            *stream = NULL;
    int              retval = -1;

    if (arg==NULL)
	goto done;
    stream = cv_string_get(arg);
    sockpath = clicon_sock(h);
    if (cli_proto_subscription(sockpath, stream, &s) < 0)
	goto done;
    
    if (cligen_regfd(s, cli_notification_cb, NULL) < 0)
	goto done;
#if 0
    if (event_reg_fd(s, cli_notification_cb, NULL, "notification socket") < 0)
	goto done;
#endif
    retval = 0;
  done:
    return retval;
}

/*
 * xml2csv. Translate XML -> CSV commands
 * Can only be made in a 'flat tree', ie on the form:
 * <X><A>B</A></X> --> 
 * Type, A
 * X,  B
 */
int 
xml2csv(FILE *f, struct xml_node *x, cvec *vh)
{
    struct xml_node *xe, *xb;
    int              retval = -1;
    cg_var          *vs;

    fprintf(f, "%s", x->xn_name);
    xe = NULL;

    vs = NULL;
    while ((vs = cvec_each(vh, vs))) {
	if ((xe = xml_find(x, cv_name_get(vs))) == NULL){
	    fprintf(f, ";");
	    continue;
	}
	if (xe->xn_nrchildren){
	    xb = xe->xn_children[0];
	    fprintf(f, ";%s", xb->xn_value);
	}
    }
    fprintf(f, "\n");
    retval = 0;
    return retval;

}


static int
show_conf_as_csv1(clicon_handle h, cvec *vars, cg_var *arg)
{
    struct xml_node *xt = NULL;
    struct xml_node *xc;
    int              retval = -1;
    struct db_spec  *dbspec, *ds=NULL; 
    cg_var          *vs;
    cvec            *vh=NULL;
    char            *str;

    dbspec = clicon_dbspec_key(h);
    if ((xt = xml_new("metrio", NULL)) == NULL)
	goto catch;
    if (show_conf_as(h, vars, arg, add2xml_cb, xt) < 0)
	goto catch;

    xc = NULL; /* Dont print xt itself */
    while ((xc = xml_child_each(xt, xc, -1)) != NULL){
	if ((str = chunk_sprintf(__FUNCTION__, "%s[]",xc->xn_name)) == NULL)
	    goto catch;
	if (ds==NULL && (ds = key2spec_key(dbspec, str)) != NULL){
	    fprintf(stdout, "Type");
	    vh = db_spec2cvec(ds);
	    vs = NULL;
	    while ((vs = cvec_each(vh, vs))) 
		fprintf(stdout, ";%s",	cv_name_get(vs));
	    fprintf(stdout, "\n");
	} /* Now values just need to follow,... */
	if (vh== NULL)
	    goto catch;
	xml2csv(stdout, xc, vh); /* cli syntax */
    }

    retval = 0;
  catch:
    if (xt)
	xml_free(xt);
    unchunk_group(__FUNCTION__);
    return retval;
}

int
show_conf_as_csv(clicon_handle h, cvec *vars, cg_var *arg)
{
    return show_conf_as_csv1(h, vars, arg);
}
