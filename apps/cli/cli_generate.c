/*
 *  CVS Version: $Id: cli_generate.c,v 1.15 2013/09/18 19:20:50 olof Exp $
 *
  Copyright (C) 2009-2014 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 *
 *     db_spec                      parse_tree                    parse_tree
 *  +-------------+ dbspec_key2cli +-------------+ dbspec2cli    +-------------+
 *  |  dbspec     | -------------> | dbclispec   | ------------> | cli         |
 *  |  A[].B !$a  | dbspec_cli2key | A <!a>{ B;} |               | syntax      |
 *  +-------------+ <------------  +-------------+               +-------------+
 *        ^                               ^
 *        |db_spec_parse_file             | dbclispec_parse
 *        |                               |
 *      <file>                          <file>
 */
#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <assert.h>
#include <fcntl.h>
#include <sys/param.h>


/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clicon/clicon.h>

#include "clicon_cli_api.h"
#include "cli_plugin.h"
#include "cli_generate.h"


/*=====================================================================
 * YANG generate CLI
 *=====================================================================*/
#if 0 /* examples/ntp */
 ntp("Network Time Protocol"),cli_set("ntp");{ 
     logging("Configure NTP message logging"),cli_set("ntp.logging");{ 
	 status (<status:bool>),cli_set("ntp.logging $status:bool");
     } 
     server("Configure NTP Server") (<ipv4addr:ipv4addr>("IPv4 address of peer")),cli_set("ntp.server[] $!ipv4addr:ipv4addr");
 }
#endif
#if 0 /* examples/datamodel */

WITH COMPLETION:
 a (<x:number>|<x:number expand_dbvar_auto("candidate a[] $!x")>),cli_set("a[] $!x");{
     b,cli_set("a[].b $!x");{ 
	 y (<y:string>|<y:string expand_dbvar_auto("candidate a[].b $!x $y")>),cli_set("a[].b $!x $y");
     } 
     z (<z:string>|<z:string expand_dbvar_auto("candidate a[] $!x $z")>),cli_set("a[] $!x $z");
 }

#endif

static int yang2cli_stmt(clicon_handle h, yang_stmt    *ys, 
			 cbuf         *xf,    
			 enum genmodel_type gt,
			 int           level);

/*
 * Check for completion (of already existent values), ranges (eg range[min:max]) and
 * patterns, (eg regexp:"[0.9]*").
 */
static int
yang2cli_var(yang_stmt    *ys, 
	     cbuf         *xf,    
	     int           completion,
	     char         *description
    )
{
    enum cv_type  cvtype;
    int           options;
    int           retval = -1;
    int64_t       range_min, range_max; 
    char         *pattern;
    char         *type;  /* orig type */
    char         *rtype; /* resolved type */

    if (yang_type_get(ys, &type, &rtype, 
		      &options, &range_min, &range_max, &pattern) < 0)
	goto done;
    if (rtype == NULL){
	clicon_err(OE_DB, 0, "%s: \"%s\": type not resolved", __FUNCTION__, type);
	goto done;
    }
    yang2cv_type(rtype, &cvtype);
    if (cvtype == CGV_ERR){
	clicon_err(OE_DB, 0, "%s: \"%s\" type not translated", __FUNCTION__, rtype);
	goto done;
    }
    if (completion)
	cprintf(xf, "(");
    cprintf(xf, "<%s:%s", ys->ys_argument, cv_type2str(cvtype));
    if (options & YANG_OPTIONS_RANGE)
	cprintf(xf, " range[%" PRId64 ":%" PRId64 "]", range_min, range_max);	
    if (options & YANG_OPTIONS_PATTERN)
	cprintf(xf, " regexp:\"%s\"", pattern);
    cprintf(xf, ">");
    if (description)
	cprintf(xf, "(\"%s\")", description);
    if (completion){
	cprintf(xf, "|<%s:%s expand_dbvar_auto(\"candidate %s\")>",
		ys->ys_argument, 
		cv_type2str(cvtype),
		yang_dbkey_get(ys));
	if (description)
	    cprintf(xf, "(\"%s\")", description);
	cprintf(xf, ")");
    }
    retval = 0;
  done:
    return retval;
}

static int
yang2cli_leaf(clicon_handle h, 
	      yang_stmt    *ys, 
	      cbuf         *xf,
	      enum genmodel_type gt,
	      int           level)
{
    yang_stmt    *yd;  /* description */
    int           retval = -1;
    char         *keyspec;
    int           completion;
    char         *description = NULL;

    completion = clicon_cli_genmodel_completion(h);
    /* description */
    if ((yd = yang_find((yang_node*)ys, Y_DESCRIPTION, NULL)) != NULL)
	description = yd->ys_argument;
    cprintf(xf, "%*s", level*3, "");
    if (gt == GT_ALL || gt == GT_VARS){
	cprintf(xf, "%s", ys->ys_argument);
	if (yd != NULL)
	    cprintf(xf, "(\"%s\")", yd->ys_argument);
	cprintf(xf, " ");
	yang2cli_var(ys, xf, completion, description);
    }
    else
	yang2cli_var(ys, xf, completion, description);


    if ((keyspec = yang_dbkey_get(ys)) != NULL)
	cprintf(xf, ",cli_set(\"%s\")", keyspec);
   cprintf(xf, ";\n");

    retval = 0;
//  done:
    return retval;
}


static int
yang2cli_container(clicon_handle h, 
		   yang_stmt    *ys, 
		   cbuf         *xf,
		   enum genmodel_type gt,
		   int           level)
{
    yang_stmt    *yc;
    yang_stmt    *yd;
    char         *keyspec;
    int           i;
    int           retval = -1;

    cprintf(xf, "%*s%s", level*3, "", ys->ys_argument);
    if ((yd = yang_find((yang_node*)ys, Y_DESCRIPTION, NULL)) != NULL)
	cprintf(xf, "(\"%s\")", yd->ys_argument);
    if ((keyspec = yang_dbkey_get(ys)) != NULL)
	cprintf(xf, ",cli_set(\"%s\");", keyspec);
   cprintf(xf, "{\n");
    for (i=0; i<ys->ys_len; i++)
	if ((yc = ys->ys_stmt[i]) != NULL)
	    if (yang2cli_stmt(h, yc, xf, gt, level+1) < 0)
		goto done;
    cprintf(xf, "%*s}\n", level*3, "");
    retval = 0;
  done:
    return retval;
}

static int
yang2cli_list(clicon_handle h, 
	      yang_stmt    *ys, 
	      cbuf         *xf,
	      enum genmodel_type gt,
	      int           level)
{
    yang_stmt    *yc;
    yang_stmt    *yd;
    yang_stmt    *ykey;
    yang_stmt    *yleaf;
    int           i;
    int           retval = -1;

    cprintf(xf, "%*s%s", level*3, "", ys->ys_argument);
    if ((yd = yang_find((yang_node*)ys, Y_DESCRIPTION, NULL)) != NULL)
	cprintf(xf, "(\"%s\")", yd->ys_argument);
    /* Look for key variable */
    if ((ykey = yang_find((yang_node*)ys, Y_KEY, NULL)) == NULL){
	clicon_err(OE_XML, errno, "List statement \"%s\" has no key", ys->ys_argument);
	goto done;
    }
    if ((yleaf = yang_find((yang_node*)ys, Y_LEAF, ykey->ys_argument)) == NULL){
	clicon_err(OE_XML, errno, "List statement \"%s\" has no key leaf \"%s\"", 
		   ys->ys_argument, ykey->ys_argument);
	goto done;
    }
    /* Print key variable now, and skip it in loop below */
    if (yang2cli_leaf(h, yleaf, xf, gt, level+1) < 0)
	goto done;
    cprintf(xf, "{\n");
    for (i=0; i<ys->ys_len; i++)
	if ((yc = ys->ys_stmt[i]) != NULL){
	    if (yc == yleaf) /* skip key leaf since done above */
		continue;
	    if (yang2cli_stmt(h, yc, xf, gt, level+1) < 0)
		goto done;
	}
    cprintf(xf, "%*s}\n", level*3, "");
    retval = 0;
  done:
    return retval;
}



/*! Translate yang-stmt to CLIgen syntax.
 */
static int
yang2cli_stmt(clicon_handle h, 
	      yang_stmt    *ys, 
	      cbuf         *xf,
	      enum genmodel_type gt,
	      int           level /* indentation level for pretty-print */
    )
{
    yang_stmt    *yc;
    int           retval = -1;
    int           i;

    switch (ys->ys_keyword){
    case Y_CONTAINER:
	if (yang2cli_container(h, ys, xf, gt, level) < 0)
	    goto done;
	break;
    case Y_LIST:
	if (yang2cli_list(h, ys, xf, gt, level) < 0)
	    goto done;
	break;
    case Y_LEAF_LIST:
    case Y_LEAF:
	if (yang2cli_leaf(h, ys, xf, gt, level) < 0)
	    goto done;
	break;
    default:
    for (i=0; i<ys->ys_len; i++)
	if ((yc = ys->ys_stmt[i]) != NULL)
	    if (yang2cli_stmt(h, yc, xf, gt, level+1) < 0)
		goto done;
	break;
    }

    retval = 0;
  done:
    return retval;

}

/*! Translate from a yang specification into a CLIgen syntax.
 *
 * Print a CLIgen syntax to xf string, then parse it.
 * @param gt - how to generate CLI: 
 *             VARS: generate keywords for regular vars only not index
 *             ALL:  generate keywords for all variables including index
 */
int
yang2cli(clicon_handle h, 
	 yang_spec *yspec, 
	 parse_tree *ptnew, 
	 enum genmodel_type gt)
{
    cbuf           *xf;
    int             i;
    int             retval = -1;
    yang_stmt      *ys = NULL;
    cvec           *globals;       /* global variables from syntax */

    if ((xf = cbuf_new()) == NULL){
	clicon_err(OE_XML, errno, "%s: cbuf_new", __FUNCTION__);
	goto done;
    }
    /* Traverse YANG specification: loop through statements */
    for (i=0; i<yspec->yp_len; i++)
	if ((ys = yspec->yp_stmt[i]) != NULL){
	    if (yang2cli_stmt(h, ys, xf, gt, 0) < 0)
		goto done;
	}
    clicon_debug(2, "%s: buf\n%s\n", __FUNCTION__, cbuf_get(xf));
    /* Parse the buffer using cligen parser. XXX why this?*/
    if ((globals = cvec_new(0)) == NULL)
	goto done;
    /* load cli syntax */
    if (cligen_parse_str(cli_cligen(h), cbuf_get(xf), 
			 "yang2cli", ptnew, globals) < 0)
	goto done;
    cvec_free(globals);

    retval = 0;
  done:
    cbuf_free(xf);
    return retval;
}
