/*
 *
  Copyright (C) 2009-2015 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 *
 * Code for comparing databases
 * XXX: needs clicon_err()
 */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <ctype.h>
#include <errno.h>
#include <string.h>
#include <regex.h>
#include <sys/types.h>
#include <sys/time.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clicon/clicon.h>

#include "config_dbdiff.h"


static int
dbdiff_add(cvec            *vr1, 
	   cvec            *vr2, 
	   enum dbdiff_op   dd_op, 
	   struct dbdiff   *df, 
	   const char      *label)
{
    cvec *vec1 = NULL;
    cvec *vec2 = NULL;
    int retval = -1;
    struct dbdiff_ent *dfe, *newents;

    if (vr1 && (vec1 = cvec_dup(vr1)) == NULL) {
	clicon_err(OE_DB, errno, "%s: cvec_dup", __FUNCTION__);
	goto quit;
    }
    if (vr2 && (vec2 = cvec_dup(vr2)) == NULL) {
	clicon_err(OE_DB, errno, "%s: cvec_dup", __FUNCTION__);
	goto quit;
    }
    df->df_nr++;
    if ((newents = rechunk(df->df_ents, 
			  df->df_nr * sizeof(struct dbdiff_ent), 
			   label)) == NULL){
	clicon_err(OE_DB, errno, "%s: rechunk", __FUNCTION__);
	goto quit;
    }
    df->df_ents = newents;
    dfe = &df->df_ents[df->df_nr-1];
    memset(dfe, 0, sizeof(*dfe));
    dfe->dfe_vec1 = vec1;
    dfe->dfe_vec2 = vec2;
    dfe->dfe_op   = dd_op;
    retval = 0;
  quit:
    return retval;
}

/*! Check if regular key 'key' exists in first, second or both databases.
 *
 * @param[in]   db1    First database
 * @param[in]   db2    Second database
 * @param[in]   key    db key
 * @param[out]  df     database diff result struct
 * @param[in]   label  chunk label
 * @retval      0      ok
 * @retval      -1     error
 */
static int
dbdiff_single(char *db1, char *db2,
	      char *key,
	      struct dbdiff *df,
	      const char *label)
{
    char  *lvec1;
    size_t lvec1_len;
    char  *lvec2;
    size_t lvec2_len;
    cvec  *vr1 = NULL;
    cvec  *vr2 = NULL;
    int    eq;
    int    retval = -1;

    if (db_get_alloc(db1,  	/* Get value from database 1 */
		     key, 
		     (void*)&lvec1, 
		     &lvec1_len) < 0)
	return -1;
    if (db_get_alloc(db2, 	/* Get value from database 2 */
		     key, 
		     (void*)&lvec2, 
		     &lvec2_len) < 0){
	free(lvec1);
	goto done;
    }
    eq = 0;
    if (lvec1_len == lvec2_len){
	if (lvec1_len == 0){
	    /* difference between lvec=NULL (no-entry) and "" (empty) */
	    if (lvec1==NULL && lvec2==NULL)
		eq++;
	    else
		if (lvec1 && lvec2) /* "" */
		    eq++;
	}
	else{
	    if (memcmp(lvec1, lvec2, lvec1_len) == 0)
		eq++;
	    }
    }

    if (!eq){
        if (lvec1) {
	    if((vr1 = lvec2cvec (lvec1, lvec1_len)) == NULL)
	        goto done;
	    cvec_name_set(vr1, key);
	}
	    
        if (lvec2) {
	    if((vr2 = lvec2cvec (lvec2, lvec2_len)) == NULL)
	        goto done;
	    cvec_name_set(vr2, key);
	}
	if (lvec1 != NULL && lvec2 != NULL){
	    if (dbdiff_add(vr1, vr2, DBDIFF_OP_BOTH, df, label) < 0)
		goto done;
	}
	else
	    if (lvec1 == NULL){
		if (dbdiff_add(NULL, vr2, DBDIFF_OP_SECOND, df,  label) < 0)
		    goto done;
	    }
	    else{
		if (dbdiff_add(vr1, NULL, DBDIFF_OP_FIRST, df, label) < 0)
		    goto done;
	    }
    }
    retval = 0;
  done:
    if (lvec1)
	free(lvec1);
    if (lvec2)
	free(lvec2);
    if (vr1)
        cvec_free(vr1);
    if (vr2)
        cvec_free(vr2);
    return retval;
}	    

/*! Detect differences between two databases and return in dbdiff structure
 * 
 * @param[in]     db1         database 1, typically running
 * @param[in]     db2         database 2, typically candidate
 * @param[in]     key         Database key pattern
 * @param[in,out] df          dbdiff struct containing list of database changes
 * @param[in]     label       label for chunk memory handling
 * 
 * @see dbdiff_vector_1 optimized version
 */
static int
dbdiff_vector(char          *db1,
	      char          *db2, 
	      char          *key,
	      struct dbdiff *df,
	      const char    *label)
{
    int                   i1;
    int                   i2;
    size_t                nitems1 = 0;
    size_t                nitems2 = 0;
    cvec                **items1 = NULL;
    cvec                **items2 = NULL;
    int                   retval = -1;

    /* List all matches from both db's */
    if (clicon_dbitems(db1, key, &items1, &nitems1) < 0) 
	goto quit;
    if (clicon_dbitems(db2, key, &items2, &nitems2) < 0) 
	goto quit;

    /* Loop through db1 items and check with db2 for adds or modifications */
    for (i1 = 0; i1 < nitems1; i1++) {
	/* Create variable mapping */
	for (i2 = 0; i2 < nitems2; i2++) {
	    /* Create variable mapping */
	    if (lv_matchvar (items1[i1], items2[i2], 0)) {
		/* We have a match. Now compare all values */
		if (lv_matchvar (items1[i1], items2[i2], 1) == 0){
		    if (dbdiff_add(items1[i1], items2[i2],
				   DBDIFF_OP_BOTH, df, label) < 0)
		        goto quit;
		}
		break;		/* break the loop */
	    }
	}
    
	if (i2 >= nitems2){	/* No match means we have added something */
	    if (dbdiff_add(items1[i1], NULL,  DBDIFF_OP_FIRST, df, label) < 0)
		goto quit;
	}
    }
    /* Now loop through db2 items and check for deleted entries in db1 items */
    for (i2 = 0; i2 < nitems2; i2++) {
	/* Create variable mapping */
	for (i1 = 0; i1 < nitems1; i1++) {
	    /* Create variable mapping */
	    if (lv_matchvar(items2[i2], items1[i1], 0)) {
		/* We have a match. This entry exist. Break the loop */
		break;		/* break the loop */
	    }
	}
	if (i1 >= nitems1){	/* No match means we have deleted something */
	    if (dbdiff_add(NULL, items2[i2], DBDIFF_OP_SECOND, df, label) < 0)
		goto quit;
	}
    }
    retval = 0;
  quit:
    if (items1)
        clicon_dbitems_free(items1, nitems1);
    if (items2)
        clicon_dbitems_free(items2, nitems2);

    return retval;
}	    




/* for caching variables and unique value */
struct _dbvars{
    cvec         *vars; 
    cg_var       *cv;
    char         *key;
}; 

static int
dbcmp(const void* arg1, const void* arg2)
{
    struct _dbvars *d1 = (struct _dbvars *)arg1;
    struct _dbvars *d2 = (struct _dbvars *)arg2;

    return cv_cmp(d1->cv, d2->cv);
}

/*! Optimized variant of dbdiff_vector() for keys with one unique variable
 *
 * @param[in]     db1         database 1, typically running
 * @param[in]     db2         database 2, typically candidate
 * @param[in]     key         Database key pattern
 * @param[in,out] df          dbdiff struct containing list of database changes
 * @param[in]     label       label for chunk memory handling
 *
 * Optimized using two sorted string arrays with linear complexity.
 * We could generalize with more than one unique variable to get rid of 
 * dbdiff_vector() bit it is still needed as fallback for the general case.
 * Now, dbregexp is the one eating most cycles 
 *
 * @see dbdiff_vector non-optimized version
*/
static int
dbdiff_vector_1(char          *db1,
		char          *db2,
		char          *key,
		struct dbdiff *df,
		char          *name, /* unique cv */
		const char    *label)
{
    int                   i1;
    int                   i2;
    struct _dbvars *v1 = NULL; /* cache of cvecs */
    struct _dbvars *v2 = NULL; 
    int                   retval = -1;
    cvec                 *vars;
    cg_var               *cv;
    int                   res;
    size_t                nitems1 = 0;
    size_t                nitems2 = 0;
    cvec                **items1 = NULL;
    cvec                **items2 = NULL;

    /* List all matches from both db's */
    if (clicon_dbitems(db1, key, &items1, &nitems1) < 0) 
	goto quit;
    if ((v1 = calloc(nitems1, sizeof(struct _dbvars))) == NULL){
	clicon_err(OE_DB, errno, "%s: calloc", __FUNCTION__);
	goto quit;
    }
    if (clicon_dbitems(db2, key, &items2, &nitems2) < 0) 
	goto quit;
    if ((v2 = calloc(nitems2, sizeof(struct _dbvars))) == NULL){
	clicon_err(OE_DB, errno, "%s: calloc", __FUNCTION__);
	goto quit;
    }
    for (i1 = 0; i1 < nitems1; i1++) {
	v1[i1].vars = vars = items1[i1];
	if ((cv = cvec_find(vars, name)) == NULL)
	    goto quit;
	if ((v1[i1].cv = cv) == NULL)
	    goto quit;
	v1[i1].key = cvec_name_get(items1[i1]);
    }
    qsort(v1, nitems1, sizeof(struct _dbvars), dbcmp);

    for (i2 = 0; i2 < nitems2; i2++){
        v2[i2].vars = vars = items2[i2];
	if ((cv = cvec_find(vars, name)) == NULL)
	    goto quit;
	if ((v2[i2].cv = cv) == NULL)
	    goto quit;
	v2[i2].key = cvec_name_get(items2[i2]);
    }
    qsort(v2, nitems2, sizeof(struct _dbvars), dbcmp);

    i1 = 0; i2 = 0;
    while (i1 < nitems1 && i2 < nitems2){
	res = cv_cmp(v1[i1].cv, v2[i2].cv);
	if (res<0){ /* in v1 but not v2 */
	    if (dbdiff_add(v1[i1++].vars, NULL, 
			   DBDIFF_OP_FIRST, df, label) < 0)
		goto quit;
	}
	else
	    if (res>0){ /* in v2 but not v1 */
		if (dbdiff_add(NULL, v2[i2++].vars, 
			       DBDIFF_OP_SECOND, df, label) < 0)
		    goto quit;
	    }
	    else{ /* equal */
		/* We have a match. Now compare all values */
		if (lv_matchvar (v1[i1].vars, v2[i2].vars, 1) == 0){
		    /* No, not equal, it has changed */
		    if (dbdiff_add(v1[i1].vars, v2[i2].vars, 
				   DBDIFF_OP_BOTH, df, label) < 0)
			goto quit;
		}
		i1++; i2++;
	    }
    }
    /* Now check if in any rests from one or the other */
    while (i1 < nitems1) /* in v1 but not v2 */
	if (dbdiff_add(v1[i1++].vars, NULL, 
		       DBDIFF_OP_FIRST, df, label) < 0)
	    goto quit;
    while (i2 < nitems2) /* in v2 but not v1 */
	if (dbdiff_add(NULL, v2[i2++].vars, 
		       DBDIFF_OP_SECOND, df, label) < 0)
	    goto quit;
    retval = 0;
  quit:
    if (items1)
        clicon_dbitems_free(items1, nitems1);
    if (items2)
        clicon_dbitems_free(items2, nitems2);
    if (v1)
        free(v1);
    if (v2)
        free(v2);

    return retval;
}	    

/*! Compare two databases
 *
 * Given two databases, db1 and db2, typically running (db1) and candidate (db2),
 * compute differences and return a db_diff structures, containing a list of entities,
 * each stating a database symbol and how it diffs.
   +---------------+     +---------------+  
   |   dbdiff      |---->|    dbdiff_ent |  [key1, key2, add/change/rm] (dfe_)
   +---------------+     +---------------+  
   (df_) from dbdiff(),   (dfe_)
 * 
 * The returned dfdiff structure is freed using unchunk_group.
 * Note: the order of the entries are according to the database spec (which in turn
 * is alphabetical).
 *
 * @param[in]     db1         database 1, typically running
 * @param[in]     db2         database 2, typically candidate
 * @param[in]     label       label for chunk memory handling
 * @param[in]     dbspec     database specification
 * @param[out]    df          dbdiff struct containing list of database changes
 */
int
db_diff(char          *db1,     
	char          *db2, 
	const char    *label,
	dbspec_key    *dbspec,
	struct dbdiff *df
    )
{
    char *basekey; 
    int retval = -1;
    dbspec_key *ds;
    char *key;
    
    /* Loop through database spec */
    for (ds=dbspec; ds; ds=ds->ds_next){
	if ((basekey = ds->ds_key) == NULL){
	    clicon_err(OE_DB, 0, "%s: No db key", __FUNCTION__);
	    goto quit;
	}
	
	/* Call relevant sub-routine to append new db-key(s) to list */
	if(key_isanyvector(basekey)) {	/* Vector key */
	    if ((key = db_gen_rxkey(basekey, __FUNCTION__)) == NULL)
		goto quit;
	    /* if ds has one unique + it is a string, then optimize */
            {
		cvec   *vh = db_spec2cvec(ds);
		cg_var *v = NULL;
		char   *name = NULL;
		int     i=0;
		while ((v = cvec_each(vh, v))) 
		    if (cv_flag(v, V_UNIQUE)){
			i++;
			name = cv_name_get(v);			    
		    }
		if (i==1 && name){ /* optimize */
		    if (dbdiff_vector_1(db1, db2, key, df, name, label) < 0)
			goto quit;
		}
		else
		    if (dbdiff_vector(db1, db2, key, df, label) < 0)
			goto quit;
	    }
	} else {					/* Single key */
	    if (dbdiff_single(db1, db2, basekey, df, label) < 0)
		goto quit;
	}
	
    } /* for() */
    retval = 0;
quit:
    unchunk_group(__FUNCTION__);
    return retval;
}

/*
 * Free cvecs in dbdiff, not dbdiff itself which needs to be unchunked
 */
void
db_diff_free(struct dbdiff *df)
{
    int i;

    for (i = 0; i < df->df_nr; i++) {
        if (df->df_ents[i].dfe_vec1)
	    cvec_free(df->df_ents[i].dfe_vec1);
        if (df->df_ents[i].dfe_vec2)
	    cvec_free(df->df_ents[i].dfe_vec2);
    }
}
