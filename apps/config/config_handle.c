/*
 *
  Copyright (C) 2009-2015 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <inttypes.h>
#include <dirent.h>
#include <errno.h>
#include <unistd.h>
#include <assert.h>
#include <fnmatch.h>
#include <sys/types.h>
#include <sys/time.h>
#include <regex.h>
#include <netinet/in.h>

/* cligen */
#include <cligen/cligen.h>

/* clicon */
#include <clicon/clicon.h>

#include "clicon_backend_api.h"
#include "config_dbdiff.h"
#include "config_dbdep.h"
#include "config_client.h"
#include "config_handle.h"

/* header part is copied from struct clicon_handle in lib/src/clicon_handle.c */

#define CLICON_MAGIC 0x99aafabe

#define handle(h) (assert(clicon_handle_check(h)==0),(struct backend_handle *)(h))

/*
 * config_handle
 * first part of this is header, same for clicon_handle and cli_handle.
 * Access functions for common fields are found in clicon lib: clicon_options.[ch]
 * This file should only contain access functions for the _specific_
 * entries in the struct below.
 */
struct backend_handle {
    int                      cb_magic;     /* magic (HDR)*/
    clicon_hash_t           *cb_copt;      /* clicon option list (HDR) */
    clicon_hash_t           *cb_data;      /* internal clicon data (HDR) */
    /* ------ end of common handle ------ */
    dbdep_t                 *cb_dbdep;     /* Database dependencies: commit checks */
    struct client_entry     *cb_ce_list;   /* The client list */
    int                      cb_ce_nr;     /* Number of clients, just increment */
};

/*
 * backend_handle_init
 * returns a clicon config handle for other CLICON API calls
 */
clicon_handle
backend_handle_init(void)
{
    return clicon_handle_init0(sizeof(struct backend_handle));
}

/*
 * clicon_backend_handle_exit
 * returns a clicon handle for other CLICON API calls
 */
int
backend_handle_exit(clicon_handle h)
{
    struct client_entry   *ce;

    dbdeps_free(h); 
    /* only delete client structs, not close sockets, etc, see backend_client_rm */
    while ((ce = backend_client_list(h)) != NULL)
	backend_client_delete(h, ce);
    clicon_handle_exit(h); /* frees h and options */
    return 0;
}

dbdep_t *
backend_dbdep(clicon_handle h)
{
    struct backend_handle *cb = handle(h);
    
    return cb->cb_dbdep;
}

int
backend_dbdep_set(clicon_handle h, dbdep_t *dbdep)
{
    struct backend_handle *cb = handle(h);

    cb->cb_dbdep = dbdep;
    return 0;
}

/*! Notify event and distribute to all registered clients
 * 
 * @param[in]  h       Clicon handle
 * @param[in]  stream  Name of event stream. CLICON is predefined as LOG stream
 * @param[in]  level   Event level (not used yet)
 * @param[in]  event   Actual message as text format
 *
 * Stream is a string used to qualify the event-stream. Distribute the
 * event to all clients registered to this backend.  
 * XXX: event-log NYI.  
 * @see also subscription_add()
 * @see also backend_notify_xml()
 */
int
backend_notify(clicon_handle h, char *stream, int level, char *event)
{
    struct client_entry *ce;
    struct subscription *su;
    int                  retval = -1;

    /* Now go thru all clients(sessions), and all subscriptions and find matches */
    for (ce = backend_client_list(h); ce; ce = ce->ce_next)
	for (su = ce->ce_subscription; su; su = su->su_next)
	    if (strcmp(su->su_stream, stream) == 0){
		if (fnmatch(su->su_filter, event, 0) == 0)
		    if (send_msg_notify(ce->ce_s, level, event) < 0)
			goto done;
	    }
    retval = 0;
  done:
    return retval;
}

/*! Notify event and distribute to all registered clients
 * 
 * @param[in]  h       Clicon handle
 * @param[in]  stream  Name of event stream. CLICON is predefined as LOG stream
 * @param[in]  level   Event level (not used yet)
 * @param[in]  event   Actual message as xml tree
 *
 * Stream is a string used to qualify the event-stream. Distribute the
 * event to all clients registered to this backend.  
 * XXX: event-log NYI.  
 * @see also subscription_add()
 * @see also backend_notify()
 */
int
backend_notify_xml(clicon_handle h, char *stream, int level, cxobj *x)
{
    struct client_entry *ce;
    struct subscription *su;
    int                  retval = -1;
    cbuf                *cb = NULL;

    /* Now go thru all clients(sessions), and all subscriptions and find matches */
    for (ce = backend_client_list(h); ce; ce = ce->ce_next)
	for (su = ce->ce_subscription; su; su = su->su_next)
	    if (strcmp(su->su_stream, stream) == 0){
		if (strlen(su->su_filter)==0 || xpath_first(x, su->su_filter) != NULL){
		    if (cb==NULL){
			if ((cb = cbuf_new()) == NULL){
			    clicon_err(OE_PLUGIN, errno, "cbuf_new");
			    goto done;
			}
			if (clicon_xml2cbuf(cb, x, 0, 0) < 0)
			    goto done;
		    }
		    if (send_msg_notify(ce->ce_s, level, cbuf_get(cb)) < 0)
			goto done;
		}
	    }
    retval = 0;
  done:
    if (cb)
	cbuf_free(cb);
    return retval;

}

struct client_entry *
backend_client_add(clicon_handle h, struct sockaddr *addr)
{
    struct backend_handle *cb = handle(h);
    struct client_entry   *ce;

    if ((ce = (struct client_entry *)malloc(sizeof(*ce))) == NULL){
	clicon_err(OE_PLUGIN, errno, "malloc");
	return NULL;
    }
    memset(ce, 0, sizeof(*ce));
    ce->ce_nr = cb->cb_ce_nr++;
    memcpy(&ce->ce_addr, addr, sizeof(*addr));
    ce->ce_next = cb->cb_ce_list;
    cb->cb_ce_list = ce;
    return ce;
}

struct client_entry *
backend_client_list(clicon_handle h)
{
    struct backend_handle *cb = handle(h);

    return cb->cb_ce_list;
}

/*! Actually remove client from list
 * See also backend_client_rm()
 */
int
backend_client_delete(clicon_handle h, struct client_entry *ce)
{
    struct client_entry   *c;
    struct client_entry  **ce_prev;
    struct backend_handle *cb = handle(h);

    ce_prev = &cb->cb_ce_list;
    for (c = *ce_prev; c; c = c->ce_next){
	if (c == ce){
	    *ce_prev = c->ce_next;
	    free(ce);
	    break;
	}
	ce_prev = &c->ce_next;
    }
    return 0;
}

