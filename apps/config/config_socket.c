 /*
 *  CVS Version: $Id: config_socket.c,v 1.28 2013/08/15 11:53:50 olof Exp $
 *
  Copyright (C) 2009-2013 Olof Hagsand and Benny Holmgren

  This file is part of CLICON.

  CLICON is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 3 of the License, or
  (at your option) any later version.

  CLICON is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with CLICON; see the file COPYING.  If not, see
  <http://www.gnu.org/licenses/>.

 */

#ifdef HAVE_CONFIG_H
#include "clicon_config.h" /* generated by config & autoconf */
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdarg.h>
#include <errno.h>
#include <signal.h>
#include <fcntl.h>
#include <time.h>
#include <syslog.h>
#include <grp.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <sys/param.h>
#ifdef HAVE_SYS_UCRED_H
#include <sys/types.h>
#include <sys/ucred.h>
#endif
#define __USE_GNU
#include <sys/socket.h>
#include <sys/param.h>
#include <sys/types.h>

#include <sys/un.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#include <cligen/cligen.h>

/* clicon */
#include <clicon/clicon.h>

#include "clicon_backend_api.h"
#include "config_socket.h"
#include "config_lib.h"
#include "config_client.h"

/*
 * \brief open a unix-domain socket and bind it to a file.
 *
 * The socket is accessed via CLICON_SOCK option, has 770 permissions
 * and group according to CLICON_SOCK_GROUP option.
 */
int
config_socket_init(clicon_handle h)
{
    int s;
    struct sockaddr_un addr;
    mode_t             old_mask;
    char              *config_sock;
    char              *config_group;
    gid_t              gid;
    struct stat        st;

    /* first find sockpath and remove it if it exists (it shouldn't) */
    if ((config_sock = clicon_sock(h)) == NULL)
	return -1;
    if (lstat(config_sock, &st) == 0 && unlink(config_sock) < 0){
	clicon_err(OE_UNIX, errno, "%s: unlink(%s)", __FUNCTION__, config_sock);
	return -1;
    }
    /* then find configuration group (for clients) and find its groupid */
    if ((config_group = clicon_sock_group(h)) == NULL)
	return -1;
    if (group_name2gid(config_group, &gid) < 0)
	return -1;
#if 0
    if (gid == 0) 
	clicon_log(LOG_WARNING, "%s: No such group: %s\n", __FUNCTION__, config_group);
#endif
    /* create unix socket */
    if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0) {
	clicon_err(OE_UNIX, errno, "%s: socket", __FUNCTION__);
	return -1;
    }

//    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (void*)&one, sizeof(one));
    memset(&addr, 0, sizeof(addr));
    addr.sun_family = AF_UNIX;
    strncpy(addr.sun_path, config_sock, sizeof(addr.sun_path)-1);
    old_mask = umask(S_IRWXO | S_IXGRP | S_IXUSR);
    if (bind(s, (struct sockaddr *)&addr, SUN_LEN(&addr)) < 0){
	clicon_err(OE_UNIX, errno, "%s: bind", __FUNCTION__);
	umask(old_mask); 
	goto err;
    }
    umask(old_mask); 
    /* change socket path file group */
    if (lchown(config_sock, -1, gid) < 0){
	clicon_err(OE_UNIX, errno, "%s: lchown(%s, %s)", __FUNCTION__, 
		config_sock, config_group);
	goto err;
    }
    clicon_debug(1, "SOCKET=%s", config_sock);
    clicon_log(LOG_DEBUG, "Binding socket to %s", addr.sun_path);
    if (listen(s, 5) < 0){
	clicon_err(OE_UNIX, errno, "%s: listen", __FUNCTION__);
	goto err;
    }
    return s;
  err:
    close(s);
    return -1;
}

/*
 * config_accept_client
 * XXX: credentials not properly implemented
 */
int
config_accept_client(int fd, void *arg)
{
    clicon_handle h = (clicon_handle)arg;
    int s;
    struct sockaddr_un from;
    socklen_t     len;
    struct client_entry *ce;
#ifdef DONT_WORK /* XXX HAVE_SYS_UCRED_H */
    struct xucred credentials; 	/* FreeBSD. */
    socklen_t     clen;
#elif defined(SO_PEERCRED)
    struct ucred credentials; 	/* Linux. */
    socklen_t     clen;
#endif
    char         *config_group;
    struct group *gr;
    char         *mem;
    int           i;

    len = sizeof(from);
    if ((s = accept(fd, (struct sockaddr*)&from, &len)) < 0){
	clicon_err(OE_UNIX, errno, "%s: accept", __FUNCTION__);
	return -1;
    }

#if defined(SO_PEERCRED)
    /* fill in the user data structure */
    clen =  sizeof(credentials);
    if(getsockopt(s, SOL_SOCKET, SO_PEERCRED/* XXX finns ej i freebsd*/, &credentials, &clen)){
	clicon_err(OE_UNIX, errno, "%s: getsockopt", __FUNCTION__);
	return 1;
    }
#endif   
    if ((ce = ce_add(&ce_list, (struct sockaddr*)&from)) == NULL)
	return -1;
#if defined(SO_PEERCRED)
    ce->ce_pid = credentials.pid;
    ce->ce_uid = credentials.uid;
#endif
    ce->ce_handle = h;

    /* check credentials of caller (not properly implemented yet) */
    if ((config_group = clicon_sock_group(h)) == NULL)
	return -1;
    if ((gr = getgrnam(config_group)) != NULL){
	i = 0; /* one of mem should correspond to ce->ce_uid */
	while ((mem = gr->gr_mem[i++]) != NULL)
	    ;
    }

#if 0
    { /* XXX */
	int ii;
	struct client_entry *c;
	for (c = ce_list, ii=0; c; c = c->ce_next, ii++);
	clicon_log(LOG_DEBUG, "Open client socket (nr:%d pid:%d [Total: %d])",
		ce->ce_nr, ce->ce_pid, ii);
    }
#endif
    ce->ce_s = s;

    /*
     * Here we register callbacks for actual data socket 
     */
    if (event_reg_fd(s, from_client, (void*)ce, "client socket") < 0)
	return -1;

    return 0;
}


